<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Michael Jenkins" />
  <meta name="date" content="2015-08-01" />
  <title>QNial the Language Definition</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="LanguageDefinition.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">QNial the Language Definition</h1>
<h2 class="author">Michael Jenkins</h2>
<h3 class="date">01 August 2015</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#the-language-definition">The Language Definition</a><ul>
<li><a href="#version-6.3">Version 6.3</a></li>
</ul></li>
<li><a href="#chapter-1-introduction">Chapter 1 Introduction</a></li>
<li><a href="#language-concepts-and-terminology">Language Concepts and Terminology</a><ul>
<li><a href="#the-objects-of-nial">The Objects of Nial</a></li>
</ul></li>
<li><a href="#chapter-2-data-objects">Chapter 2 Data Objects</a><ul>
<li><a href="#atomic-arrays">Atomic Arrays</a></li>
<li><a href="#rectangularity-structure">Rectangularity Structure</a></li>
<li><a href="#nesting-structure">Nesting Structure</a></li>
<li><a href="#empty-arrays">Empty Arrays</a></li>
<li><a href="#array-diagrams">Array Diagrams</a></li>
</ul></li>
<li><a href="#chapter-3-predefined-data-operations">Chapter 3 Predefined Data Operations</a><ul>
<li><a href="#properties-of-data">Properties of Data</a></li>
<li><a href="#logic-operations">Logic Operations</a></li>
<li><a href="#arithmetic-operations">Arithmetic Operations</a></li>
<li><a href="#linear-algebra-operations">Linear Algebra Operations</a></li>
<li><a href="#comparison-operations">Comparison Operations</a></li>
<li><a href="#type-testing-operations">Type Testing Operations</a></li>
<li><a href="#set-like-operations">Set-like Operations</a></li>
<li><a href="#conversion-operations">Conversion Operations</a></li>
<li><a href="#structure-testing-operations">Structure Testing Operations</a></li>
<li><a href="#measurement-operations">Measurement Operations</a></li>
<li><a href="#array-construction-operations">Array Construction Operations</a></li>
<li><a href="#reshaping-operations">Reshaping Operations</a></li>
<li><a href="#array-generation-operations">Array Generation Operations</a></li>
<li><a href="#selection-operations">Selection Operations</a></li>
<li><a href="#insertion-operations">Insertion Operations</a></li>
<li><a href="#searching-operations">Searching Operations</a></li>
<li><a href="#nesting-restructuring-operations">Nesting Restructuring Operations</a></li>
<li><a href="#data-rearrangement-operations">Data Rearrangement Operations</a></li>
<li><a href="#string-manipulation-operations-using-regular-expressions">String Manipulation Operations using Regular Expressions</a></li>
</ul></li>
<li><a href="#chapter-4-predefined-transformers">Chapter 4 Predefined Transformers</a><ul>
<li><a href="#each-and-related-transformers">Each and Related Transformers</a></li>
<li><a href="#partitioning-transformers">Partitioning Transformers</a></li>
<li><a href="#applicative-transformers">Applicative Transformers</a></li>
<li><a href="#sorting-transformers">Sorting Transformers</a></li>
<li><a href="#reduction-transformers">Reduction Transformers</a></li>
<li><a href="#control-structure-transformers">Control Structure Transformers</a></li>
<li><a href="#selection-transformer">Selection Transformer</a></li>
</ul></li>
<li><a href="#chapter-5-the-formal-description-of-nial-programs">Chapter 5 The Formal Description of Nial Programs</a><ul>
<li><a href="#environment">Environment</a></li>
<li><a href="#action">Action</a></li>
<li><a href="#definition">Definition</a></li>
<li><a href="#external-declaration">External Declaration</a></li>
<li><a href="#remark">Remark</a></li>
<li><a href="#array-expression">Array Expression</a></li>
<li><a href="#expression-sequence">Expression Sequence</a></li>
<li><a href="#simple-expression">Simple Expression</a></li>
<li><a href="#primary-expressions">Primary Expressions</a></li>
<li><a href="#constant">Constant</a></li>
<li><a href="#variable">Variable</a></li>
<li><a href="#scope-of-a-variable">Scope of a Variable</a></li>
<li><a href="#indexed-variable">Indexed Variable</a></li>
<li><a href="#named-expression">Named Expression</a></li>
<li><a href="#expression-list">Expression List</a></li>
<li><a href="#parenthesized-expression-sequence">Parenthesized Expression Sequence</a></li>
<li><a href="#block">Block</a></li>
<li><a href="#local-and-nonlocal-declaration">Local and Nonlocal Declaration</a></li>
<li><a href="#nested-definition">Nested Definition</a></li>
<li><a href="#cast">Cast</a></li>
<li><a href="#assign-expression">Assign Expression</a></li>
<li><a href="#selection-expression">Selection Expression</a></li>
<li><a href="#loop-expression">Loop Expression</a></li>
<li><a href="#comment">Comment</a></li>
<li><a href="#operation-expression">Operation Expression</a></li>
<li><a href="#simple-operation">Simple Operation</a></li>
<li><a href="#operation-form">Operation Form</a></li>
<li><a href="#transformer-expression">Transformer Expression</a></li>
<li><a href="#transformer-form">Transformer Form</a></li>
<li><a href="#summary-of-juxtapositional-syntax">Summary of Juxtapositional Syntax</a></li>
<li><a href="#synonyms">Synonyms</a></li>
</ul></li>
<li><a href="#chapter-6-file-input-and-output-operations">Chapter 6 File Input and Output Operations</a><ul>
<li><a href="#sequential-files">Sequential Files</a></li>
<li><a href="#qnial-specific-direct-access-file-operations">Q'Nial Specific Direct Access File Operations</a></li>
<li><a href="#direct-access-operations-for-host-files">Direct Access Operations for Host Files</a></li>
</ul></li>
<li><a href="#chapter-7-operations-for-the-interpreter-mechanisms">Chapter 7 Operations for the Interpreter Mechanisms</a><ul>
<li><a href="#top-level-loop">Top Level Loop</a></li>
<li><a href="#picture-operations">Picture Operations</a></li>
<li><a href="#phrases-names-and-casts">Phrases, Names and Casts</a></li>
<li><a href="#dynamic-execution-of-name-associations">Dynamic Execution of Name Associations</a></li>
</ul></li>
<li><a href="#chapter-8-management-of-the-programming-environment">Chapter 8 Management of the Programming Environment</a><ul>
<li><a href="#the-qnial-programming-environment">The Q'Nial Programming Environment</a></li>
<li><a href="#invoking-qnial">Invoking Q'Nial</a></li>
<li><a href="#naming-the-latest-result">Naming the Latest Result</a></li>
<li><a href="#session-related-expressions-and-operations">Session Related Expressions and Operations</a></li>
<li><a href="#restarting-a-qnial-session">Restarting a Q'Nial Session</a></li>
<li><a href="#ending-a-qnial-session">Ending a Q'Nial Session</a></li>
<li><a href="#interrupts-and-error-recovery">Interrupts and Error Recovery</a></li>
<li><a href="#fault-triggering">Fault Triggering</a></li>
<li><a href="#workspace-management">Workspace Management</a></li>
<li><a href="#saving-and-loading-the-workspace">Saving and Loading the Workspace</a></li>
<li><a href="#loading-a-definition-file">Loading a Definition File</a></li>
<li><a href="#setting-workspace-switches">Setting Workspace Switches</a></li>
<li><a href="#workspace-status">Workspace Status</a></li>
<li><a href="#symbol-table">Symbol Table</a></li>
<li><a href="#logging-the-work-of-the-session">Logging the Work of the Session</a></li>
<li><a href="#time-related-expressions">Time Related Expressions</a></li>
<li><a href="#display-related-settings">Display Related Settings</a></li>
<li><a href="#real-number-formatting">Real Number Formatting</a></li>
<li><a href="#system-related-expressions">System Related Expressions</a></li>
<li><a href="#host-interface-operations">Host Interface Operations</a></li>
<li><a href="#session-and-workspace-variables">Session and Workspace Variables</a></li>
</ul></li>
<li><a href="#chapter-9-debugging-and-profiling-nial-definitions">Chapter 9 Debugging and Profiling Nial Definitions</a><ul>
<li><a href="#debugging-definitions">Debugging Definitions</a></li>
<li><a href="#defining-a-break-point">Defining a Break Point</a></li>
<li><a href="#access-to-intermediate-scopes">Access to Intermediate Scopes</a></li>
<li><a href="#debugging-commands">Debugging Commands</a></li>
<li><a href="#repeating-debug-commands">Repeating Debug Commands</a></li>
<li><a href="#monitoring-execution-flow">Monitoring Execution Flow</a></li>
<li><a href="#watch-mechanism">Watch Mechanism</a></li>
<li><a href="#trace-mechanism">Trace Mechanism</a></li>
<li><a href="#profiling-capability">Profiling Capability</a></li>
</ul></li>
</ul>
</div>
<h1 id="the-language-definition">The Language Definition</h1>
<h2 id="version-6.3">Version 6.3</h2>
<p><strong>August 2006</strong></p>
<p><strong>Nial Systems Limited</strong></p>
<p><strong>Preface</strong></p>
<p>The Language Definition manual consists of nine chapters that describe the Nial language at a technical level and provides summary informa tion on the capabilities of the Q'Nial interpreter.</p>
<p><em>Chapter 1</em> introduces some of the concepts and terminology of Nial. <em>Chapter 2</em> describes the data objects of the language. <em>Chapters 3 and 4</em> cover the predefined operations and transformers in Nial. <em>Chapter 5</em> gives a formal description of the syntax and semantics of Nial using BNF style syntax descriptions and natural language descriptions of the meaning of the constructs. <em>Chapter 6</em> covers the file input and output operations. <em>Chapter 7</em> describes the operations that provide access to the mechanisms of the Q'Nial interpreter. <em>Chapter 8</em> introduces the Q'Nial environment. <em>Chapter 9</em> describes the debugging and profiling capabilities of the Q'Nial interpreter.</p>
<h1 id="chapter-1-introduction">Chapter 1 Introduction</h1>
<p><strong>Nial</strong> is an acronym for the <strong>N</strong>ested <strong>I</strong>nteractive <strong>A</strong>rray <strong>L</strong>anguage. Nial is a <em>language</em> intended for users of computers who wish to describe a computational procedure (often called an algorithm) to solve a particular problem or process data in a desired way. The word <em>interactive</em> refers to the idea of having a conversation of sorts with the computer. In essence, the program mer types a fragment of a program into the computer and the computer replies immediately indicating the result of processing that part of the program. The word <em>array</em> refers to a data structure which is manipulated by Nial. An array can be a single number or character, a list of numbers, a table of numbers or almost any other structure desired. The word <em>nested</em> refers to the fact that an item of an array can be another array or an operation can contain another operation. The idea is akin to Russian dolls that can be taken apart to reveal a smaller doll inside.</p>
<p>The Nial language was designed by Mike Jenkins and Trenchard More during a collaborating that began in 1979 and continued for many years. The current version is a refinement developed by NIAL Systems Limited based on its experience with the practical use in many application areas.</p>
<p><strong>Q'Nial</strong> is a computer program initially developed at Queen's University, Kingston that implements the Nial language. It was used to support research in computer science on programming languages, knowledge-based systems and other topics at Queen's and other universities. NIAL Systems Limited has took over responsibility for the development and marketing of Q'Nial and delivered it to customers in many countries. Mike Jenkins continues to use Q'Nial and has made it freely available through the company web site at www.nial.com.</p>
<p>Q'Nial is intended for use as both a rapid prototyping tool for exploring how to design a program to address a particular problem, and as a rapid development tool to build a program for a known task quickly. It implements a very high level language in that many details of programming are done by Q'Nial without explicit specification. A programmer can think about and work on whole data structures rather than just the individual items that make up the structure. By using a prototyping approach, many of the design considerations in a large program can be resolved before a great investment in programming occurs. As well, users can work with a prototype version of the ultimate system, using a working model that has the screens and some of the functionality of the final system.</p>
<p>The emphasis in Nial on powerful data operations that apply to entire data sets means that Nial programs tend to be 1/5 of the size or smaller of an equivalent C or Pascal program. This makes Nial well-suited for rapid development of data intensive programs.</p>
<h1 id="language-concepts-and-terminology">Language Concepts and Terminology</h1>
<p>The programming language Nial and its implementation, Q'Nial, are designed to make the learning of programming concepts easy. In normal use of Q'Nial, a programmer enters a small fragment of a program through the keyboard. Q'Nial interprets the entry and returns the result immediately. This instant response provides feedback on the correctness of the program text. Programs can be entered interactively and a workspace of functional and data objects can be built while exploring how to handle a programming requirement. As well, Q'Nial is designed to support the creation of programs as text stored in one or more text files.</p>
<h2 id="the-objects-of-nial">The Objects of Nial</h2>
<p>The major focus of Nial is on the creation and manipulation of data objects which are organised under a structuring scheme known as <strong>nested rectangular arrays</strong> (or <strong>arrays</strong> for short).</p>
<p>An <strong>expression</strong> is a construction used to create arrays. Operations and transformers are functional objects used in the construction of expressions.</p>
<p>When the Q'Nial interpreter evaluates a program fragment that is a Nial expression, it returns an array data structure. Examples of expressions are constants, list constructions, conditional expressions, loops, assignment expressions and operation calls. An expres sion may also be made up of a number of steps which describe an algorithm or procedure for computing an array.</p>
<p>An <strong>operation</strong> is a <em>functional</em> object that is given an argument array and returns a result array. An operation is used by <strong>applying</strong> it to an argument; this process of executing an operation by giving it an argument value is called an <strong>operation call</strong>.</p>
<p>An operation can be constructed by defining one or more parameters and giving an algorithm to compute the result in terms of the parameters. There are also program fragments (operation expressions) that construct unnamed operations by composing operations, forming a list of operations, or modifying an operation by use of a transformer.</p>
<p>A <strong>transformer</strong> is a <em>functional</em> object that is used to construct a new operation from a given operation argument, producing a modified version of the given operation. Most transformers used in Nial are provided in the core language. However, there is a mechanism to construct a new transformer in terms of one or more operation parameters. A user-defined transformer describes the modified operation as a parameterized algorithm (a <strong>schema</strong>) for manipulating data.</p>
<p>The process of evaluating an operation call of an operation modified by a transformer requires two steps. The modified operation is formed; and then the modified operation is given the array argument which it uses to produce the result.</p>
<p>The object construction mechanisms are extended by two naming conventions: <strong>variable assignment</strong> and <strong>definition</strong>. A variable assignment associates a name with an array value dynamically during execution of expressions. A definition associates a name with a program fragment in a static manner.</p>
<h1 id="chapter-2-data-objects">Chapter 2 Data Objects</h1>
<p>The data objects of Nial are nested rectangular arrays. Atomic data objects such as numbers and characters are included within this description by virtue of an atom being considered as a self-containing array object with no dimensions.</p>
<h2 id="atomic-arrays">Atomic Arrays</h2>
<p>There are six types of atoms in Nial. They are boolean, integer, real, character, phrase and fault. The first three are <strong>numeric</strong> types and are used for arithmetic operations. The last three are <strong>literal</strong> types and are used for symbol manipulation. All six types of atoms are used in comparisons.</p>
<p>A <strong>boolean</strong> atom is the result of a comparison of array values; or the result of a test relating to a characteris tic of an array or the content of an array. There are two boolean atoms: <strong>true</strong> and <strong>false</strong>, denoted by<strong>l</strong> and<strong>o</strong> respectively. When boolean atoms are treated as numbers, <em>true</em> corresponds to one and <em>false</em> to zero.</p>
<p>An <strong>integer</strong> atom is a positive or negative whole number representing a quantity of units. A dash symbol (-) immediately preceding the integer denotes a negative integer. No space is permitted between the dash and the number, otherwise the dash is interpre ted as the arithmetical operation of subtraction. Conversely, a space is required when subtraction is intended and the right argument is a number. An integer is represented by an internal form that limits its range of values in the Q'Nial implementation of Nial.</p>
<p>A <strong>real</strong> atom is a number which can represent any position on the real line. It may be written with a fractional part and/or with a decimal exponent. It is represented internally by a floating point number.</p>
<p>A <strong>character</strong> atom represents a single glyph within the standard character set in use. The notation for a single character in Nial is the grave symbol ( ` ), preceding the character.</p>
<p>A <strong>phrase</strong> is an atom of literal information in which a sequence of characters is taken as a unit. Phrases are used in the place of character strings when the internal structure of the string does not need to be manipulated. Constant phrases are denoted in Nial text by placing the double quote symbol ( &quot; ) before the sequence of characters. Phrases may also be constructed by applying the operation <em>phrase</em> to a character string.</p>
<p>A <strong>fault</strong> is an atom of literal information similar to a phrase, used to identify data concerning extraordinary or erroneous conditions. Constant faults are denoted in Nial by placing the question mark symbol ( ? ) before the sequence of characters. Faults may also be constructed by applying the operation <em>fault</em> to a character string. By convention, the text of a fault normally begins with a question mark. For example, <em>?A</em> denotes an arithmetic fault and <em>?L</em> denotes a fault in a logic operation. To denote<em>?A</em> in Nial text ??A is typed.</p>
<p>There are a small number of special fault values <em>?noexpr, ?eof, ?O</em> and <em>?I</em>. These arise in the execution of Nial expressions to indicate that no value is available for the expression. All other faults can be viewed as error conditions. A fault triggering mechanism is available in Q'Nial to detect when faults other than the four special ones are created. The triggering mechanism is on by default but can be turned on or off under program control or at start up.</p>
<h2 id="rectangularity-structure">Rectangularity Structure</h2>
<p>An <strong>array</strong> is a collection of data objects having its items held at locations in a rectangular structure. The items are viewed as being objects at locations that are positioned relative to a set of directions at right angles to each other. In mathematical terminology, an array is said to have a set of orthogonal axes. The items may be arranged along zero, one, two or more directions. For example, the following array is a 4 by 6 table of numbers. It has 24 items arranged along two directions of length 4 and 6 respectively.</p>
<pre><code>+---+---+---+---+---+---+
|499|434|122|770|733|890|
+---+---+---+---+---+---+
|660| 32|808| 24|  5|473|
+---+---+---+---+---+---+
|499|434|122|770|733|890|
+---+---+---+---+---+---+
|660| 32|808| 24|  5|473|
+---+---+---+---+---+---+</code></pre>
<p>The number of axes of an array is referred to as its dimensionality. The number of axes is the number of dimensions. In mathematical terminology this dimensionality is called the <strong>valence</strong> of the array. The following terms describe arrays by their valence:</p>
<table>
<caption><strong>Valence Table</strong></caption>
<thead>
<tr class="header">
<th align="left">Valence</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">single</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">list, vector</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">table, matrix</td>
</tr>
<tr class="even">
<td align="left">2 or more</td>
<td align="left">multivalent</td>
</tr>
</tbody>
</table>
<p>The concept of a structure with no directions is, at first glance, paradoxical. If a structure has no directions, how can it have a location? However, allowing a structure to have no directions permits atomic data such as an integer or a character to be treated as a data structure in a manner consistent with the treatment of structures having one or more directions.</p>
<p>The rectangular structure of an array can be des cribed by its length in each direction. The list of these lengths is called the <strong>shape</strong> of the array. The <em>shape</em> of an array has one item for each direction and hence is of length equal to the dimensionality, or <em>valence</em>, of the array. The <em>shape</em> of an array is itself an array.</p>
<p>The array displayed above is a table that has, as its shape, the array:</p>
<pre><code>+-+-+
|4|6|
+-+-+</code></pre>
<p>The shape of an array with no axes, a <strong>single</strong>, is the predefined empty list <strong>Null</strong>. All atoms are defined to be singles and hence have <em>Null</em> as their shape.</p>
<p>The number of items in an array is called the <strong>tally</strong> of the array. Because an array is rectangular, the tally is the product of the shape. By convention in mathematics, the product of the empty list <em>Null</em> is one; thus, a single always contains exactly one item. An atom is characterized by the fact that it is self-containing, that is, an atom is its own item.</p>
<p><strong>Lists</strong>, arrays with one dimension, are encountered frequently in Nial. The following terminology is used for the most common ones:</p>
<table>
<thead>
<tr class="header">
<th align="left">Number of Items In the List</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">empty list</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">solitary</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">pair</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">triple</td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">quadruple</td>
</tr>
</tbody>
</table>
<p>The shape of a list is a solitary list holding the length of the list. The notation [A, B,...] is used to denote a list whose items are A, B, ... etc. Thus, the expression [4, 6] is a pair and its shape is the solitary list [2].</p>
<p>A solitary and a single both have one item. They differ in rectangular structure in the following way:</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">single</th>
<th align="left">solitary</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">valence</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">shape</td>
<td align="left">Null</td>
<td align="left">[1]</td>
</tr>
<tr class="odd">
<td align="left">tally</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody>
</table>
<p>Two forms of lists are also classified by their content. A <strong>string</strong> is a list of characters. A <strong>bitstring</strong> is a list of booleans.</p>
<p>A <strong>location</strong> in an array is described by a list of integers. Each item of the list of integers indicates the position of the location along the corresponding axis. The list of integers is called the <strong>address</strong> of the location in the array. The counting scheme uses zero origin indexing. Thus, in the table above, the address of 496 is [2,3]. For simplicity, the addresses of a list are integers: 0, 1, etc. For convenience, in situations where an address or a shape of a list is expected, an integer and the solitary holding the integer are treated equivalently. The operation <em>gage</em> is used to convert a solitary list of integers to an integer and returns any other list of integers directly.</p>
<p>All the addresses of an array can be stored in an array of the same rectangular structure as the array itself. Such an array is called the <strong>grid</strong> of an array. The grid of a list is a list of integers. The grid of table <em>T</em>above is the following table of pairs of integers.</p>
<pre><code>+-----+-----+-----+-----+-----+-----+
|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|
||0|0|||0|1|||0|2|||0|3|||0|4|||0|5||
|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|
+-----+-----+-----+-----+-----+-----+
|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|
||1|0|||1|1|||1|2|||1|3|||1|4|||1|5||
|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|
+-----+-----+-----+-----+-----+-----+
|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|
||2|0|||2|1|||2|2|||2|3|||2|4|||2|5||
|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|
+-----+-----+-----+-----+-----+-----+
|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|
||3|0|||3|1|||3|2|||3|3|||3|4|||3|5||
|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|+-+-+|
+-----+-----+-----+-----+-----+-----+</code></pre>
<h2 id="nesting-structure">Nesting Structure</h2>
<p>The arrays of Nial are a <strong>recursive data type</strong>, that is, the items of an array are also arrays. The above example of the grid of a 4 by 6 table is an example of a nested array. Each of the items is a pair, a list of length two, of integers.</p>
<p>Since an array has arrays as items, it may contain data at lower levels than the top one. A <strong>path</strong> is a list of addresses that describes the <strong>site</strong> of a data object at some depth within the array. For example, the path [[2, 5], 1] is the path to the second item in the pair at address [2, 5] in the grid of <em>T</em> shown above.</p>
<p>An array is said to be <strong>simple</strong> if all its items are atomic. The table of numbers, <em>T</em> above is simple but the table of its grid is not.</p>
<p>A <strong>part</strong>of an array is a data object that is contained at some level within the array. The atomic parts of an array are called the <strong>leaves</strong> of the array. The simple parts are called <strong>twigs</strong>.</p>
<p>The term <strong>level</strong> is used informally to describe the relative position of a part within the nesting structure of an array. An item is at the first or top level, an item of an item is at the second level, etc.</p>
<p>An atom is viewed in two ways. As an indivisible data object it is viewed as having no levels and cannot be broken into subarrays. As an array data structure it is viewed as a single holding itself and therefore has an infinity of levels. This view is necessary for atomic arrays to fit the theory of nested array mathematics.</p>
<p>The number of levels to reach an atom along each path need not be the same. For example, in the following array, the phrase &quot;hello is at the first level, the integer 23 is at the second level and the character `b is at the third level.</p>
<pre><code>[ 23 &#39;abc&#39;, &quot;hello , tell 2 2 ]

+------------+-----+-------------+
|+--+-------+|hello|+-----+-----+|
||23|+-+-+-+||     ||+-+-+|+-+-+||
||  ||a|b|c|||     |||0|0|||0|1|||
||  |+-+-+-+||     ||+-+-+|+-+-+||
|+--+-------+|     |+-----+-----+|
|            |     ||+-+-+|+-+-+||
|            |     |||1|0|||1|1|||
|            |     ||+-+-+|+-+-+||
|            |     |+-----+-----+|
+------------+-----+-------------+</code></pre>
<h2 id="empty-arrays">Empty Arrays</h2>
<p>An <strong>empty</strong> array is one that has no items. The most commonly encountered empty array is the empty list; it is the shape of a single. The empty list can be denoted in three ways in Nial: by the predefined symbol <em>Null</em>; by the list constructor notation with no items; and by the string notation with no characters. This is summarized by:</p>
<table>
<thead>
<tr class="header">
<th align="left">Construction</th>
<th align="left">Denotation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Predefined name</td>
<td align="left">Null</td>
</tr>
<tr class="even">
<td align="left">List Constructor</td>
<td align="left">[ ]</td>
</tr>
<tr class="odd">
<td align="left">String Notation</td>
<td align="left">''</td>
</tr>
</tbody>
</table>
<p><strong>Figure 2-6 Ways of Denoting the Empty List</strong></p>
<p>An empty array may have length in some directions. For example, an empty table of shape [2,0] is one with two rows but no columns. Two empty arrays are equal only if their shapes are equal. By definition, an empty array is simple.</p>
<h2 id="array-diagrams">Array Diagrams</h2>
<p>The result of a Nial expression is indicated by displaying a <strong>picture</strong> of the result. An array picture is a table of characters that shows the content and structure of an array. The structure of the array is displayed by laying out pictures of the items in a two-dimensional format with or without a frame. The size of the layout is adjusted to leave room for the size of the pictures of the items, which may themselves be pictures of arbitrary complexity.</p>
<p>The form of the picture display is controlled by two independent mode switches. The first switch has two settings, <strong>diagram</strong> and <strong>sketch</strong>. The picture of an atom shows the atom itself in either sketch or diagram mode. <strong>Diagram</strong>mode shows the complete nesting structure of an array. It provides a frame around each item. <strong>Sketch</strong>mode eliminates the frame around the items of a simple array.</p>
<p>The other switch has two settings, <strong>decor</strong> and <strong>nodecor</strong>. When decor is set, characters, phrases and faults are decorated so that the type of data is obvious. Once a mode is set, it remains in use until it is reset.</p>
<p>The picture of an array of three or more dimensions is displayed by a tabular layout of the pictures of the two-dimensional subarrays along the last two dimensions. An array with three axes is displayed as three tables across the page with space between each table. An array with four axes is displayed as a table of pictures of the two-dimensional subarrays with space between each table. As the dimensionality increases, the process of alternating the direction of display continues with increasing space between the pictures of lower dimensional arrays.</p>
<p>The sketch displays of an array of integers of shape 2 3 2 3 and of a 2 3 table of 2 3 tables are:</p>
<pre><code>a := 2 3 2 3 reshape count 36

1   2  3  7  8  9 13 14 15
4   5  6 10 11 12 16 17 18
19 20 21 25 26 27 31 32 33
22 23 24 28 29 30 34 35 36


2 raise A

+--------+--------+--------+
|  1 2 3 |   7 8 9|13 14 15|
|  4 5 6 |10 11 12|16 17 18|
+--------+--------+--------+
|19 20 21|25 26 27|31 32 33|
|22 23 24|28 29 30|34 35 36|
+--------+--------+--------+</code></pre>
<p>A single has no axes and hence cannot be diagrammed in a conventional way. If a non-atomic array is a single, its picture has the character o in the upper left corner.</p>
<pre><code>single 1 2 3

o-----+
|1 2 3|
+-----+</code></pre>
<p>The diagram of a solitary has the usual corner box character in the upper left corner.</p>
<pre><code>solitary 1 2 3

+-----+
|1 2 3|
+-----+</code></pre>
<p>In sketch mode, the display of an empty array is suppressed. In diagram mode, the display of an empty array shows the frame border. For example, the display of an empty list is the left border of the frame diagram for a list.</p>
<pre><code>set &quot;diagram; Null

+
|
+</code></pre>
<p>The display of an empty table is the upper left corner of the frame and if the table has a non zero length, the display includes the frame along one side. The array <em>A</em>, defined below, is displayed in the four mode combinations as follows:</p>
<pre><code>A := 2 3 reshape [5 &#39;PC&#39;, &quot;hello, single 2 4, tell 1 2, solitary &#39;Hi&#39;, tell 0 2];

set &quot;diagram; set &quot;decor; A

+--------------+---------+-------+
|+-+---------+|&quot;hello   |o-----+|
||5|+---+---+||         ||+-+-+||
|| ||`P |`C |||         |||2|4|||
|| |+---+---+||         ||+-+-+||
|+-+---------+|         |+-----+|
+-------------+---------+-------+  
|+-----+-----+|+-------+|+-+-+  |
||+-+-+|+-+-+|||+--+--+||       |
|||0|0|||0|1|||||`H|`i|||       |
||+-+-+|+-+-+|||+--+--+||       |
|+-----+-----+|+-------+|       |
+-------------+---------+-------+


set&quot;diagram; set &quot;nodecor; A

+-------------+-------+-------+
|+-+-----+ |hello     |o-----+|
||5|+-+-+| |          ||+-+-+||
|| ||P|C|| |          |||2|4|||
|| |+-+-+| |          ||+-+-+||
|+-+-----+ |          |+-----+|
+-------------+-------+-------+
|+-----+-----+|+-----+|+-+-+  |
||+-+-+|+-+-+|||+-+-+||       |
|||0|0|||0|1|||||H|i|||       |
||+-+-+|+-+-+|||+-+-+||       |
|+-----+-----+|+-----+|       |
+-------------+-------+-------+



set &quot;sketch; set &quot;decor; A

+---------+------+-----+
|+-+----+ |&quot;hello|o---+|
||5|&#39;PC&#39;| |      ||2 4||
|+-+----+ |      |+---+|
+---------+------+-----+
|+---+---+|+----+|     |
||0 0|0 1|||&#39;Hi&#39;||     |
|+---+---+|+----+|     |
+---------+------+-----+


set &quot;sketch; set &quot;nodecor; A

+---------+-----+-----+
|+-+--+ |&quot;hello |o---+|
||5|PC| |       ||2 4||
|+-+--+ |       |+---+|
+---------+-----+-----+
|+---+---+|+--+ |     |
||0 0|0 1|||Hi| |     |
|+---+---+|+--+ |     |
+---------+-----+-----+</code></pre>
<h1 id="chapter-3-predefined-data-operations">Chapter 3 Predefined Data Operations</h1>
<p>Programming in Nial is mainly done by creating operations that carry out data transformations from some input data to desired output data and then combining these using the expression mechanisms to find the solution to a given problem. The programming task is accomplished by making use of the predefined operations of Nial.</p>
<p>This chapter gives a brief description of the data operations provided with Q'Nial, grouped by topic area. Detailed descriptions of the operations, organized alphabetically, are given in the <em>Nial Dictionary</em>.</p>
<p>Most of the predefined operations are directly implemented in the Q'Nial interpreter. However, a few of them are written in Nial itself and are defined in a file that can be modified by a Q'Nial user. The file <em>defs.ndf</em> in the <em>initial</em> directory holds these definitions.</p>
<h2 id="properties-of-data">Properties of Data</h2>
<p>A <strong>binary operation</strong> is one that must have a pair of arrays as its argument. If the argument is not a pair, a fault is returned.</p>
<p>Some of the operations of Nial that operate on simple arrays are extended to arbitrarily nested arrays by being applied to the atoms at the deepest level. These are called <strong>pervasive</strong> <strong>operations</strong>. There are three classes of pervasive operations: unary pervasive, binary pervasive and multi pervasive.</p>
<p>An example of a <strong>unary pervasive</strong> operation is <em>abs</em> which returns the absolute value of a numeric atom. When a unary pervasive operation is applied to a non-atomic argument, it returns an array of the same structure as the argument. The atoms of the result are the result of applying the operation to the corresponding atoms of the argument. A unary pervasive operation <em>f</em> applied to a non-atomic array A gives the same result as applying f to each item of A. That is,</p>
<pre><code>f A = EACH f A

abs -3.5 27 -8
3.5 27 8</code></pre>
<p>An example of a <strong>binary pervasive</strong> operation is <em>minus</em>, also denoted by -, which returns the difference of two numbers.</p>
<p>Consider two nonatomic arrays, <em>A</em> and <em>B</em>, of identical structure. When a binary pervasive operation such as <em>minus</em> is applied to them as in <em>A minus B</em>, the resulting array <em>C</em> has the same structure as <em>A</em> or <em>B</em>. <em>C</em> has atoms that are the result of applying <em>minus</em> to the pairs of atoms in corresponding positions of <em>A</em> and <em>B</em>.</p>
<pre><code>3 5 7 - 2 8 3
1 -3 4</code></pre>
<p>A binary pervasive operation <em>f</em> satisfies the equation</p>
<p>   <em>A f B = A EACHBOTH f B</em></p>
<p>A unary operation which reduces a simple array to an atom is <strong>multi pervasive</strong>.</p>
<p>When a multi pervasive operation, such as <em>sum</em>, is applied to an array <em>A</em> with items all of identical structure, it returns an array of that same structure. The atoms of the result are computed by applying <em>sum</em> to the simple arrays formed by taking the atoms from positions in the corresponding items of the argument.</p>
<p>Thus, for example, if <em>T</em> is a table, <em>sum rows T</em> returns the column totals for <em>T</em>.</p>
<pre><code>T := 2 4 reshape count 8

1 2 3 4
5 6 7 8


rows T

+-------+-------+
|1 2 3 4|5 6 7 8|
+-------+-------+


sum rows T

6 8 10 12</code></pre>
<p>A multi pervasive operation used on a pair behaves in precisely the same manner as a binary pervasive operation.</p>
<p>A multi pervasive operation <em>f</em> satisfies the equations</p>
<p>   <em>f A = EACHALL f A</em><br />
   <em>f A = REDUCE f A</em></p>
<p>In binary pervasive and multi pervasive operations, the items of the argument must all be of the same shape and structure. If they are not, items that have only one item, (eg. atoms, singles and solitaries), are reshaped to the common shape. If all items with more than one item are not the same shape, the fault <em>?conform</em> is returned.</p>
<p>A <strong>predicate</strong> is an operation that tests a condition and returns <em>true</em> if the condition holds and <em>false</em> otherwise. A predicate is not pervasive.</p>
<h2 id="logic-operations">Logic Operations</h2>
<p>A <strong>logic</strong> operation is one that combines arrays of booleans or produces a result of booleans. The predefined logic operations follow:</p>
<dl>
<dt><strong><em>A = B</em></strong></dt>
<dd><p><em>true</em> if <em>A</em> and <em>B</em> are the same array value; <em>false</em> otherwise</p>
</dd>
<dt><strong><em>A ~= B</em></strong></dt>
<dd><p><em>true</em> if <em>A</em> and <em>B</em> are not the same array value; <em>false</em> otherwise</p>
</dd>
<dt><strong><em>= A</em></strong></dt>
<dd><p><em>true</em> if all the items of A are equal; <em>false</em> otherwise,</p>
</dd>
<dt><strong><em>diverse A</em></strong></dt>
<dd><p><em>true</em> if no two items of <em>A</em> are the same array value; <em>false</em> otherwise</p>
</dd>
<dt><strong><em>and A</em></strong></dt>
<dd><p><em>true</em> if all the items of <em>A</em> are <em>true</em>; <em>false</em> otherwise</p>
</dd>
<dt><strong><em>or A</em></strong></dt>
<dd><p><em>true</em> if at least one item of <em>A</em> is <em>true</em>; <em>false</em> otherwise</p>
</dd>
<dt><strong><em>not A</em></strong></dt>
<dd><p>the opposite boolean from <em>A</em></p>
</dd>
</dl>
<p>The operations <em>equal</em> and <em>unequal</em> are synonyms for <em>=</em> and <em>~=</em> respectively. The infix use of <em>equal</em> is a special case of the prefix use that tests if all the items of an array are the same. The operation <em>diverse</em> is the opposite test. The operations <em>and</em> and <em>or</em> are multi pervasive; <em>not</em> is unary pervasive. They provide the fundamental operations of boolean logic in a very general setting.</p>
<h2 id="arithmetic-operations">Arithmetic Operations</h2>
<p>The <em>arithmetic</em> operations include elementary and modular arithmetic<br />
operations and operations for real number computations in science and engineering.</p>
<p>Arithmetic formulae may be applied to single numbers or to nested collections of numbers. There is also a random number generation operation. The arithmetic operations are given below by class of pervasiveness:</p>
<table style="width:99%;">
<colgroup>
<col width="33%" />
<col width="34%" />
<col width="30%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Unary Pervasive</th>
<th align="left">Binary Pervasive</th>
<th align="left">Multi Pervasive</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">opposite, sin</td>
<td align="left">plus</td>
<td align="left">sum +</td>
</tr>
<tr class="even">
<td align="left">reciprocal, cos</td>
<td align="left">minus -</td>
<td align="left">product *</td>
</tr>
<tr class="odd">
<td align="left">floor, tan</td>
<td align="left">times</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">ceiling, arcsin</td>
<td align="left">divide /</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">sqrt, arccos</td>
<td align="left">mod</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">abs, arctan</td>
<td align="left">quotient</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">exp, sinh</td>
<td align="left">power</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">ln, cosh</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">log, tanh</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>All of the above operation names and syonyms represent the corresponding mathematical functions where <em>sqrt</em> is square root, <em>abs</em> is absolute value, <em>exp</em> is exponent, <em>ln</em> is natural logarithm, <em>log</em> is logarithm to the base 10 and <em>mod</em> is modulus.</p>
<p>The standard programming symbols for arithmetic can be used. The symbol <em>+</em> is a synonym for <em>sum</em>. It can be used both in a prefix way to sum an array of numbers or in an infix way to add two numbers together. Since <em>sum</em> is pervasive, its meaning is extended to do itemwise additions.</p>
<p>The symbol <em>-</em> must be used with care in Nial. It is a synonym for <em>minus</em> and can form part of a negative number. When used as <em>minus</em> it must be separated from a following number by at least one space to avoid ambiguity.</p>
<p>The operation <em>opposite</em> reverses the sign of a number.</p>
<h2 id="linear-algebra-operations">Linear Algebra Operations</h2>
<p>Q'Nial supports the following linear algebra operations; as well, <em>inv</em> is provided as a synonym for <em>inverse</em> and <em>ip</em> is one for<em>innerproduct</em>:</p>
<dl>
<dt><strong><em>inverse A</em></strong></dt>
<dd><p>The inverse of square matrix <em>A</em></p>
</dd>
<dt><strong><em>innerproduct A B</em></strong></dt>
<dd><p>The inner product of A and B.</p>
</dd>
<dt><strong><em>solve A B</em></strong></dt>
<dd><p>The values of <em>X</em> that satisfy the set of linear equations <em>AX=B</em></p>
</dd>
</dl>
<h2 id="comparison-operations">Comparison Operations</h2>
<p>The <strong>comparison</strong> operations compare numeric or literal atoms according to an implicit ordering. All the comparison operations are pervasive. They are given below by class of pervasiveness:</p>
<table>
<thead>
<tr class="header">
<th align="left">Binary Pervasive</th>
<th align="left">Multi Pervasive</th>
<th align="left">Non Pervasive</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">&lt; &lt;=</td>
<td align="left">max</td>
<td align="left">up</td>
</tr>
<tr class="even">
<td align="left">&gt; &gt;=</td>
<td align="left">min</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">match</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">mate</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>The operations <em>gt</em>, <em>lt</em>, <em>gte</em> and <em>lte</em> are synonyms for <em>&gt;</em>, <em>&lt;</em>, <em>&gt;=</em> and <em>&lt;=</em>, respectively.</p>
<p>The comparison operations are defined for all atomic types. For numeric types, the comparison reflects the usual ordering of the numbers. For characters and phrases, the comparison is made by using a predefined collating sequence. For phrases and faults, the comparison is judged on the first character that differs.</p>
<p>Comparisons between numeric types and nonnumeric types are defined to be <em>false</em>, as are comparisons between phrases and single characters.</p>
<p>The operations <em>&lt;, &lt;=, &gt;, &gt;=,</em> and <em>mate</em> convert numeric arguments to be the same type before doing the comparison. The operation <em>match</em> does an equal comparison of atoms without conversion whereas <em>mate</em> does an equal comparison with conversion.</p>
<p>The operations <em>max</em> and <em>min</em> find the upper and lower bounds of the items of the argument, respectively. Special faults are returned to indicate the top (<em>?I</em>) and bottom (<em>?O</em>) of the pre-lattice of atomic objects if there are no items or if the items are incomparable.</p>
<p>The operation <em>up</em> defines a total ordering on the arrays of Nial. It compares valence, then length of axes in order, and then items. Atomic items are compared by type, and if of equal type by <em>lte</em>. Non-atomic items are compared by applying <em>up</em> recursively.</p>
<h2 id="type-testing-operations">Type Testing Operations</h2>
<p>The operation <em>type</em> is unary pervasive and returns a representative atom corresponding to its argument type as defined by the following table.</p>
<p><strong>Representative</strong></p>
<table>
<thead>
<tr class="header">
<th align="left">Atomic type</th>
<th align="left">Atom</th>
<th align="left">Predicate</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">boolean</td>
<td align="left">o</td>
<td align="left">isboolean</td>
</tr>
<tr class="even">
<td align="left">integer</td>
<td align="left">0</td>
<td align="left">isinteger</td>
</tr>
<tr class="odd">
<td align="left">real number</td>
<td align="left">0.</td>
<td align="left">isreal</td>
</tr>
<tr class="even">
<td align="left">character</td>
<td align="left">&lt;blank&gt;</td>
<td align="left">ischar</td>
</tr>
<tr class="odd">
<td align="left">phrase</td>
<td align="left">&quot;&quot;</td>
<td align="left">isphrase</td>
</tr>
<tr class="even">
<td align="left">fault</td>
<td align="left">??</td>
<td align="left">isfault</td>
</tr>
</tbody>
</table>
<p>The operation <em>type</em> can be used to test whether an atom is of a particular type. For convenience a predicate is provided for testing each atomic type directly. For convenience, there is an additional predicate operation, <em>isstring</em> to test whether or not an array is a string.</p>
<h2 id="set-like-operations">Set-like Operations</h2>
<p>There are two set-like operations defined in <em>defs.ndf</em>.</p>
<dl>
<dt><strong><em>allin A B</em></strong></dt>
<dd><p>Tests whether or not all items of <em>A</em> are in <em>B</em>.</p>
</dd>
<dt><strong><em>like A B</em></strong></dt>
<dd><p>Tests whether or not all items of <em>A</em> are in <em>B</em> and vice versa.</p>
</dd>
</dl>
<h2 id="conversion-operations">Conversion Operations</h2>
<p>A common requirement in programming is to convert data from one representation to another. For example, numbers are read from a file in literal form as a string but are required in numeric form for arithmetic calculations. Alternately, numbers are converted to a string representation before they are written to a file.</p>
<p>The <strong>conversion</strong> operations return a result of the type specified by the operation name.</p>
<table>
<thead>
<tr class="header">
<th align="left">Operation</th>
<th align="left">From</th>
<th align="left">To</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">string</td>
<td align="left">atom</td>
<td align="left">string</td>
</tr>
<tr class="even">
<td align="left">phrase</td>
<td align="left">string</td>
<td align="left">phrase</td>
</tr>
<tr class="odd">
<td align="left">fault</td>
<td align="left">string</td>
<td align="left">fault</td>
</tr>
<tr class="even">
<td align="left">quiet_fault</td>
<td align="left">string</td>
<td align="left">fault</td>
</tr>
<tr class="odd">
<td align="left">char</td>
<td align="left">integer</td>
<td align="left">character</td>
</tr>
<tr class="even">
<td align="left">charrep</td>
<td align="left">character</td>
<td align="left">integer</td>
</tr>
<tr class="odd">
<td align="left">tonumber</td>
<td align="left">string</td>
<td align="left">number</td>
</tr>
<tr class="even">
<td align="left">tolower</td>
<td align="left">string</td>
<td align="left">lower case string</td>
</tr>
<tr class="odd">
<td align="left">toupper</td>
<td align="left">string</td>
<td align="left">upper case string</td>
</tr>
<tr class="even">
<td align="left">toraw</td>
<td align="left">simple</td>
<td align="left">bitstring</td>
</tr>
<tr class="odd">
<td align="left">fromraw</td>
<td align="left">bitstring</td>
<td align="left">simple</td>
</tr>
<tr class="even">
<td align="left">gage</td>
<td align="left">array</td>
<td align="left">simple integers</td>
</tr>
</tbody>
</table>
<p>Operations <em>toupper</em> and <em>tolower</em> take an atomic character or a string argument and return one in which the letters have been changed to upper or lower case respectively. The operations <em>char</em> and <em>charrep</em> are unary pervasive. The operations <em>toraw</em> and <em>fromraw</em> are used to convert simple arrays of characters or numbers into bitstrings in order to do low level bit manipulation. The operation <em>gage</em> is used to remove unnecessary structure from an array representing a shape or address.</p>
<h2 id="structure-testing-operations">Structure Testing Operations</h2>
<p>The following table describes operations that test the structure of an array. The test that an array is simple always holds if an array is atomic or if it is empty.</p>
<dl>
<dt><strong><em>atomic A</em></strong></dt>
<dd><p><em>A</em> is an atom.</p>
</dd>
<dt><strong><em>simple A</em></strong></dt>
<dd><p>All items of <em>A</em> are atoms.</p>
</dd>
<dt><strong><em>empty A</em></strong></dt>
<dd><p><em>A</em> has no items.</p>
</dd>
</dl>
<h2 id="measurement-operations">Measurement Operations</h2>
<p>The following table describes operations that measure the structure of an ar ray. They can be used to construct other tests on the structure of an array.</p>
<dl>
<dt><strong><em>tally A</em></strong></dt>
<dd><p>number of items in <em>A</em></p>
</dd>
<dt><strong><em>valence A</em></strong></dt>
<dd><p>number of axes that <em>A</em> has</p>
</dd>
<dt><strong><em>shape A</em></strong></dt>
<dd><p>list of the lengths of axes of <em>A</em></p>
</dd>
<dt><strong><em>axes A</em></strong></dt>
<dd><p>list of the axis numbers for <em>A</em></p>
</dd>
</dl>
<h2 id="array-construction-operations">Array Construction Operations</h2>
<p>The following table describes several operations that <strong>construct</strong> an array from one or more components. These include the unary operations, <em>single</em> and <em>solitary</em>, that add a level and enclose an argument array as an item, the binary operations, <em>pair</em>, <em>hitch</em> and <em>append</em>, that join two arrays into a new structure, and four operations, <em>link</em>, <em>cart</em>, <em>laminate</em>, and <em>catenate</em> that combine an arbitrary number of arrays into a new structure. The operations <em>link</em> and <em>cart</em> are unary, but are often used in infix mode to combine two arrays.</p>
<dl>
<dt><strong><em>single A</em></strong></dt>
<dd><p>single holding <em>A</em> as its item</p>
</dd>
<dt><strong><em>solitary A</em></strong></dt>
<dd><p>solitary holding <em>A</em> as its item</p>
</dd>
<dt><strong><em>A pair B</em></strong></dt>
<dd><p>list of 2 items having items <em>A</em> and <em>B</em></p>
</dd>
<dt><strong><em>A hitch B</em></strong></dt>
<dd><p>list having <em>A</em> as the first item and the items of <em>B</em> as the remaining items</p>
</dd>
<dt><strong><em>A append B</em></strong></dt>
<dd><p>list with items of <em>A</em> as the beginning items followed by <em>B</em> as the last item</p>
</dd>
<dt><strong><em>link A</em></strong></dt>
<dd><p>list with items of items of <em>A</em> in orde</p>
</dd>
<dt><strong><em>cart A</em></strong></dt>
<dd><p>array of all arrays of the same shape as <em>A</em> taking one item from each of the items of <em>A</em></p>
</dd>
<dt><strong><em>I laminate A</em></strong></dt>
<dd><p>merged items of <em>A</em> along a new axis before axis <em>I</em> of the items</p>
</dd>
<dt><strong><em>I catenate A</em></strong></dt>
<dd><p>items of <em>A</em> joined along axis <em>I</em></p>
</dd>
</dl>
<h2 id="reshaping-operations">Reshaping Operations</h2>
<p>The following table describes the operations that preserve the level structure and ordering of items of an array, but possibly alter the shape. The operation <em>reshape</em> is used both for providing shape and for replicating items if there are not enough to fill out the desired shape. The operation <em>pass</em> serves as the identity operation on arrays and is provided for mathematical completeness.</p>
<dl>
<dt><strong><em>A reshape B</em></strong></dt>
<dd><p>array having shape <em>A</em> and items taken from <em>B</em> cyclically</p>
</dd>
<dt><strong><em>list A</em></strong></dt>
<dd><p>list of items of <em>A</em></p>
</dd>
<dt><strong><em>pass A</em></strong></dt>
<dd><p><em>A</em>, unchanged</p>
</dd>
<dt><strong><em>post A</em></strong></dt>
<dd><p>table with tally <em>A</em> rows and one column holding the items of <em>A</em></p>
</dd>
</dl>
<h2 id="array-generation-operations">Array Generation Operations</h2>
<p>The operations that are used to generate arrays are described in next.</p>
<dl>
<dt><strong><em>tell A</em></strong></dt>
<dd><p>array of addresses for an array of shape <em>A</em> in 0 origin</p>
</dd>
<dt><strong><em>count A</em></strong></dt>
<dd><p>array of shape <em>A</em> equal to <em>1 + tell A</em></p>
</dd>
<dt><strong><em>grid A</em></strong></dt>
<dd><p>array with the same shape as <em>A</em> holding the addresses of <em>A</em></p>
</dd>
<dt><strong><em>random S</em></strong></dt>
<dd><p>An array of uniformly distributed random real numbers between 0.0 and 1.0 of shape <em>S</em>. The value returned depends on the current value of the internal seed.</p>
</dd>
<dt><strong><em>seed A</em></strong></dt>
<dd><p>Sets the random number seed to <em>A</em>, a real number between 0. and 1.</p>
</dd>
</dl>
<p>The operations <em>tell</em> and <em>grid</em> generate arrays of addresses. The operation random is used to generate pseudo random numbers. A seed number is initialized when a Nial session is started and subsequent numbers are generated using a linear congruential method. The operation <em>seed</em> can be used to reset the generator.</p>
<h2 id="selection-operations">Selection Operations</h2>
<p>Many of the operations involve the <strong>selection</strong> of an array from a given array according to some control argument. The selected array may be an item, an array of items of the given array or an array deep in the nesting structure of the array. The selection operations are described below.</p>
<p>The operations <em>take</em> and <em>drop</em> use a negative value to indicate that the right end or bottom parts of the array are to be taken or dropped. Earlier versions had operations <em>takeright</em> and <em>dropright</em> that defined in <em>defs.ndf</em> for compatibility.</p>
<dl>
<dt><strong><em>first A</em></strong></dt>
<dd><p>first item of <em>A</em></p>
</dd>
<dt><strong><em>second A</em></strong></dt>
<dd><p>second item of <em>A</em></p>
</dd>
<dt><strong><em>third A</em></strong></dt>
<dd><p>third item of <em>A</em></p>
</dd>
<dt><strong><em>last A</em></strong></dt>
<dd><p>last item of <em>A</em></p>
</dd>
<dt><strong><em>A pick B</em></strong></dt>
<dd><p>item of <em>B</em> at address <em>A</em></p>
</dd>
<dt><strong><em>A choose B</em></strong></dt>
<dd><p>array of the same shape as <em>A</em> with items selected from <em>B</em> according to addresses <em>A</em></p>
</dd>
<dt><strong><em>A reach B</em></strong></dt>
<dd><p>part of <em>B</em> that is reached by succes sive <em>pick</em> operations using the items of path <em>A</em></p>
</dd>
<dt><strong><em>A take B</em></strong></dt>
<dd><p>corner of <em>B</em> with shape <em>abs A</em> chosen by signs of items of <em>A</em></p>
</dd>
<dt><strong><em>A drop B</em></strong></dt>
<dd><p>corner of <em>B</em> left after dropping extents of length <em>abs A</em> from the ends speci fied by the signs of items of A</p>
</dd>
<dt><strong><em>A sublist B</em></strong></dt>
<dd><p>list of items of <em>B</em> selected according to the boolean pattern <em>A</em>, where <em>true</em> indicates selection</p>
</dd>
<dt><strong><em>A except B</em></strong></dt>
<dd><p>list of items of <em>A</em> not in <em>B</em></p>
</dd>
<dt><strong><em>front A</em></strong></dt>
<dd><p>list of items of <em>A</em> excluding the last</p>
</dd>
<dt><strong><em>rest A</em></strong></dt>
<dd><p>list of items of <em>A</em> excluding the first</p>
</dd>
<dt><strong><em>cull A</em></strong></dt>
<dd><p>list of unique items in <em>A</em></p>
</dd>
<dt><strong><em>A cut B</em></strong></dt>
<dd><p>list of lists of items of <em>B</em> separated at positionscorresponding to <em>true</em> values in <em>A</em>, eliminating items of <em>B</em> inpositions corresponding to <em>true</em></p>
</dd>
<dt><strong><em>A cutall B</em></strong></dt>
<dd><p>list of lists of items of <em>B</em> separated at positions corresponding to <em>true</em> values in <em>A,</em> with all items of <em>B</em> retained in the result</p>
</dd>
</dl>
<h2 id="insertion-operations">Insertion Operations</h2>
<p>The operations <em>pick, choose</em> and <em>reach</em> select an array from a given array using addresses. The corresponding operations that insert items according to addresses are <em>place, placeall</em> and <em>deepplace</em>.</p>
<dl>
<dt><strong><em>A B place C</em></strong></dt>
<dd><p>array that is the same as <em>C</em> except that the item at address <em>B</em> is replaced by <em>A</em></p>
</dd>
<dt><strong><em>A B placeall C</em></strong></dt>
<dd><p>array that is the same as <em>C</em> except that items at addresses <em>B</em> are repla ced by items of <em>A</em></p>
</dd>
<dt><strong><em>A B deepplace C</em></strong></dt>
<dd><p>array the same as <em>C</em> except that the part at path <em>B</em> is replaced by <em>A</em></p>
</dd>
</dl>
<p>The notations described in Chapter 5 provide an alternative way to achieve selection and insertion in arrays.</p>
<h2 id="searching-operations">Searching Operations</h2>
<p>The table below describes operations that locate one array in another. The operation <em>seek</em> combines the work of <em>find</em> and <em>in</em> since both can be done with one search. There are two search algorithms used internally. If <em>B</em> has been sorted with <em>sortup</em>, a binary search is done; otherwise a linear is search is used.</p>
<dl>
<dt><strong><em>A find B</em></strong></dt>
<dd><p>address of the first position in <em>B</em> that holds <em>A</em>; if <em>A</em> is not an item of <em>B</em>, then <em>gage</em> <em>shape B</em></p>
</dd>
<dt><strong><em>A in B</em></strong></dt>
<dd><p><em>true</em> if <em>A</em> is an item of <em>B</em>; otherwise<em>false</em></p>
</dd>
<dt><strong><em>A notin B</em></strong></dt>
<dd><p><em>true</em> if <em>A</em> is not an item of <em>B</em>; otherwise<em>false</em></p>
</dd>
<dt><strong><em>A seek B</em></strong></dt>
<dd><p>pair with first item <em>A in B</em> and second item <em>A find B</em></p>
</dd>
<dt><strong><em>A findall</em></strong></dt>
<dd><p>list of addresses of all positions in <em>B</em> that hold <em>A</em></p>
</dd>
</dl>
<h2 id="nesting-restructuring-operations">Nesting Restructuring Operations</h2>
<p>The next table describes operations that add or remove levels to an array by splitting or merging arrays along axes. The operations <em>rows</em>, <em>cols</em>, <em>raise</em> and <em>lower</em> are all special cases of <em>split</em>. The operation <em>mix</em> is a special case of <em>blend</em> in which the axes of the items are placed at the end of the axes of the result. The operation <em>content</em> removes all nesting structure from the array, returning the atoms at the leaves as a list.</p>
<dl>
<dt><strong><em>rows A</em></strong></dt>
<dd><p>rows of <em>A</em></p>
</dd>
<dt><strong><em>cols A</em></strong></dt>
<dd><p>columns of <em>A</em></p>
</dd>
<dt><strong><em>mix A</em></strong></dt>
<dd><p>array formed by merging the first two levels of <em>A</em>, placing the axes of the top level first</p>
</dd>
<dt><strong><em>A raise B</em></strong></dt>
<dd><p>array containing arrays of items of <em>B</em> partitioned along axes so that the result has the first <em>A</em> axes of <em>B</em></p>
</dd>
<dt><strong><em>A lower B</em></strong></dt>
<dd><p>array containing arrays of items of <em>B</em> partitioned along axes so that the items have the last <em>A</em> axes of <em>B</em></p>
</dd>
<dt><strong><em>A split B</em></strong></dt>
<dd><p>arrays of items of <em>B</em> where the axes mentioned in <em>A</em> become the axes of the items of the result</p>
</dd>
<dt><strong><em>A blend B</em></strong></dt>
<dd><p>array of valence equal to <em>valence of B</em> plus the <em>valence</em> of an item of <em>B</em> obtained by merging <em>axes</em> of B according to axis numbers in <em>A</em></p>
</dd>
<dt><strong><em>content A</em></strong></dt>
<dd><p>A list of atoms of <em>A</em> in depth-first row-major order</p>
</dd>
</dl>
<h2 id="data-rearrangement-operations">Data Rearrangement Operations</h2>
<p>The table below describes the operations that involve the rearrangement of items within an array. The operations <em>reverse</em> and <em>rotate</em> work on the list of items of the array, leaving the result in an array of the same shape as originally given.</p>
<p>The operation <em>transpose</em> interchanges items in the array to produce the array with the axes in reverse order. It is a special case of the <em>fuse</em>, which does a reordering and possible fusion of axes according to the axis numbers in its left argument. If the argument is a nested array, items with 2 or more axis numbers indicate that the corresponding diagonal elements along those axes should be selected.</p>
<p>The operation <em>pack</em> interchanges the top two levels of its argument. Thus, if its is given a pair of triples the result is a triple of pairs.</p>
<dl>
<dt><strong><em>reverse A</em></strong></dt>
<dd><p>array of the same shape as <em>A</em> with the items of <em>A</em> in reverse order</p>
</dd>
<dt><strong><em>N rotate A</em></strong></dt>
<dd><p><em>A</em> with items rotated <em>N</em> places. If <em>N &gt; 0</em>, the items are rotated to the left; if <em>N &lt; 0</em>, the items are rotated to the right.</p>
</dd>
<dt><strong><em>transpose A</em></strong></dt>
<dd><p>array formed by reversing axes of <em>A</em></p>
</dd>
<dt><strong><em>A fuse B</em></strong></dt>
<dd><p>array formed from <em>B</em> with the axes reordered according to permutation <em>A</em>. Non-atomic items in <em>A</em> specify axes to be merged by diagonalization.</p>
</dd>
<dt><strong><em>pack A</em></strong></dt>
<dd><p>array formed by interchanging the top two levels of <em>A</em> after replicating items with one item to the same shape as the other items</p>
</dd>
</dl>
<h2 id="string-manipulation-operations-using-regular-expressions">String Manipulation Operations using Regular Expressions</h2>
<p>Regular expressions are string patterns commonly used to describe a search in a string for substrings that have some desired property. The first table below describes the notation for regular expressions used by some of the string manipulation operations described in the second table.</p>
<table style="width:142%;">
<colgroup>
<col width="43%" />
<col width="98%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Notation</th>
<th align="left">Matching String</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">.</td>
<td align="left">any character</td>
</tr>
<tr class="even">
<td align="left">*</td>
<td align="left">the previous character zero or more times</td>
</tr>
<tr class="odd">
<td align="left">+</td>
<td align="left">the previous character 1 or more times</td>
</tr>
<tr class="even">
<td align="left">^</td>
<td align="left">when at the beginning of a regular expression, matches the beginning of the string.</td>
</tr>
<tr class="odd">
<td align="left">$</td>
<td align="left">when at the end of a regular expression, matches the end of the string.</td>
</tr>
<tr class="even">
<td align="left">[xyz]</td>
<td align="left">any character in the sequence of characters &quot;xyz&quot; where ?xyz? can be almost any sequence of characters.</td>
</tr>
<tr class="odd">
<td align="left">[^xyz]</td>
<td align="left">any character NOT in the sequence of characters &quot;xyz&quot;.</td>
</tr>
<tr class="even">
<td align="left">[x-y]</td>
<td align="left">any character in the range of x to y.</td>
</tr>
<tr class="odd">
<td align="left">|</td>
<td align="left">allows the optional match of the regular expression on the left or the right of the &quot;|&quot;.</td>
</tr>
<tr class="even">
<td align="left">()</td>
<td align="left">bracketing allows the specification of <em>groups</em>. Anything that is matched between a set of brackets can later be extracted. Also used for bracketing regular expressions to force order of precedence.</td>
</tr>
<tr class="odd">
<td align="left">&lt;other char&gt;</td>
<td align="left">matches itself</td>
</tr>
<tr class="even">
<td align="left">\&lt;char&gt;</td>
<td align="left">matches the character</td>
</tr>
</tbody>
</table>
<dl>
<dt><strong><em>regexp R S</em></strong></dt>
<dd><p>Applies the regular expression <em>R</em> to string <em>S</em> and returns a list. The first item is a boolean indicating if the search succeeded. The second item is the first substring matched by <em>R</em> and the remaining items, if any, are the substrings that match the subgroups indicated by parentheses in <em>R</em>.</p>
</dd>
<dt><strong><em>regexp_match R S [O]</em></strong></dt>
<dd><p>Applies the regular expression <em>R</em> to string <em>S</em> and returns a boolean indicating if the search succeeded. If <em>O</em> is ?i then the search is case insensitive.</p>
</dd>
<dt><strong><em>regexp_substitute R S T [O]</em></strong></dt>
<dd><p>Applies the regular expression <em>R</em> to string <em>T</em> doing substitutions based on <em>S</em>. Return the modified string if the search matches; otherwise return <em>T</em>. O provides options for case insensitive search (?i) or for doing all substitutions (?g).</p>
</dd>
<dt><strong><em>string_split C S [N]</em></strong></dt>
<dd><p>Splits the string <em>S</em> whenever one of the character in <em>C</em> occurs in <em>S</em>, eliminating the character. <em>N</em> indicates a limit on the number of substrings obtained.</p>
</dd>
<dt><strong><em>string_translate C D S [O]</em></strong></dt>
<dd><p>Translates characters in string <em>S</em> based on mapping characters in <em>C</em> to the corresponding ones in <em>D</em>. Options include (?d) to delete characters and (?c) to complement characters and (??s) to squeeze many occurrences to one.</p>
</dd>
</dl>
<p>The string manipulation operations are based on a package of public domain C++ routines developed by Henry Spencer at the University of Toronto. The regular expressions obey the standard syntax rules for regular expressions used in Perl and Unix software.</p>
<h1 id="chapter-4-predefined-transformers">Chapter 4 Predefined Transformers</h1>
<p>The expressiveness of using operations to achieve a solution to a computational problem is enhanced by the use of transformers or operation modifiers. A <strong>transformer</strong> maps a predefined or user defined operation to a related operation. It is said to be a <em>second order function</em> because it has an operation (a first order function) as both its argument and its result. This chapter provides brief descriptions of the transformers or operation modifiers that are built into Q'Nial. More complete descriptions of the predefined transformers, along with examples are found in the <em>Nial Dictionary</em>.</p>
<h2 id="each-and-related-transformers">Each and Related Transformers</h2>
<p>The most important transformer is <em>EACH</em>. It modifies an operation so that the operation is applied to the items of an array rather than the array itself. The result is an array of the same shape as the array to which the modified operation is applied. There is a family of transformers related to <em>EACH</em> in that they apply the argument operation to arrays formed from parts of the argument. The transformers <em>EACHLEFT</em>, <em>EACHRIGHT</em> and <em>EACHBOTH</em> produce binary operations. They are described in the following table:</p>
<dl>
<dt><strong><em>EACH f A</em></strong></dt>
<dd><p>items of <em>A</em></p>
</dd>
<dt><strong><em>A EACHLEFT f B</em></strong></dt>
<dd><p>pairs formed from items of <em>A</em> and array <em>B</em></p>
</dd>
<dt><strong><em>A EACHRIGHT f B</em></strong></dt>
<dd><p>pairs formed from array <em>A</em> and items of <em>B</em></p>
</dd>
<dt><strong><em>A EACHBOTH f B</em></strong></dt>
<dd><p>pairs formed from items of <em>A</em> paired with corresponding items of <em>B</em></p>
</dd>
<dt><strong><em>EACHALL f A</em></strong></dt>
<dd><p>arrays of the same shape as <em>A</em> formed from corresponding items of items of <em>A</em></p>
</dd>
<dt><strong><em>TWIG f A</em></strong></dt>
<dd><p>deeply nested simple arrays of <em>A</em></p>
</dd>
<dt><strong><em>LEAF f A</em></strong></dt>
<dd><p>deeply nested atoms of <em>A</em></p>
</dd>
</dl>
<h2 id="partitioning-transformers">Partitioning Transformers</h2>
<p>The transformers described below apply their argument operation to partitions of an array and then build an array by using the results of the applications as partitions of the result. The transformer <em>RANK</em> is primitive and the others are defined from it in <em>defs.ndf</em>. The last two transformers do a reduction of the given operation to the partitions.</p>
<dl>
<dt><strong><em>N RANK f A</em></strong></dt>
<dd><p>items of <em>N lower A; mix</em></p>
</dd>
<dt><strong><em>[A,B] PARTITION f C</em></strong></dt>
<dd><p>items of <em>A split C</em>; <em>B blend</em></p>
</dd>
<dt><strong><em>BYROWS f A</em></strong></dt>
<dd><p>items of <em>rows</em> <em>A; mix</em></p>
</dd>
<dt><strong><em>BYCOLS f A</em></strong></dt>
<dd><p>items of <em>cols</em> <em>A; 1 blend</em></p>
</dd>
<dt><strong><em>REDUCEROWS f A</em></strong></dt>
<dd><p>reduce <em>items of rows A; mix</em></p>
</dd>
<dt><strong><em>REDUCECOLS f A</em></strong></dt>
<dd><p>reduce <em>items of cols A; 1 blend</em></p>
</dd>
</dl>
<h2 id="applicative-transformers">Applicative Transformers</h2>
<p>There are a number of transformers described below that control how an operation or an atlas of operations is applied.</p>
<dl>
<dt><strong><em>A CONVERSE f B</em></strong></dt>
<dd><p>result of <em>B f A</em></p>
</dd>
<dt><strong><em>N FOLD f A</em></strong></dt>
<dd><p>apply <em>f</em> to <em>A</em>; and then to the result, etc. <em>N</em> times</p>
</dd>
<dt><strong><em>TEAM f A</em></strong></dt>
<dd><p>operations in atlas <em>f</em> are applied to items in corresponding positions in <em>A</em>; if <em>f</em> is an operation other than an atlas, it is applied directly to <em>A</em></p>
</dd>
<dt><strong><em>OUTER f A</em></strong></dt>
<dd><p>apply<em>f</em> to the items of <em>cart A</em>, the array of all combinations of items of items of <em>A</em></p>
</dd>
<dt><strong><em>A INNER [f,g] B</em></strong></dt>
<dd><p>generalized inner product using a reductive operation <em>f</em> to reduce each list formed from the outer product of the binary pervasive operation g applied to the<br />
 rows of <em>A</em> and the columns of <em>B</em></p>
</dd>
</dl>
<p>The transformers <em>OUTER</em> and <em>INNER</em> generalize the outer and inner product concepts from linear algebra. The expression <em>A OUTER * B</em>, where <em>A</em> and <em>B</em> are numeric vectors, produces the matrix formed by multiplying each item of <em>A</em> with each item of <em>B</em>. <em>A INNER [+,*] B</em> does matrix multiplication if <em>A</em> and <em>B</em> are conformable matrices.</p>
<h2 id="sorting-transformers">Sorting Transformers</h2>
<p>The sorting of data objects depends on a comparison operation that describes the desired ordering relation on the items. The operation <em>up</em> provides a total ordering for the universe of arrays; the operation <em>lte</em> (<em>&lt;=</em>) provides a partial ordering of the universe of atoms.</p>
<p>The transformer <em>SORT</em> expects as its argument a comparator that will partially or totally order the universe of the items to which the resulting operation will be applied. When the modified operation is applied the result is an array of the same shape as the argument with the items in order according to the comparator.</p>
<p>The transformer <em>GRADE</em> is similar to <em>SORT</em> except applying the modified operation returns a permutation array which, if used to <em>choose</em> the argument, will result in the sorted array.</p>
<dl>
<dt><strong><em>SORT f A</em></strong></dt>
<dd><p>array of <em>shape A</em> of the items of <em>A</em> sorted according to <em>f</em>. If <em>f</em> is <em>&lt;=</em>, the items are returned in ascending sequence</p>
</dd>
<dt><strong><em>GRADE f A</em></strong></dt>
<dd><p>indices of the items of <em>A</em> in the sequence such that choosing the items according to the sequence of the indices returns the items sorted according to <em>f</em></p>
</dd>
</dl>
<p>The operations <em>sortup</em> and <em>gradeup</em> are defined in <em>defs.ndf</em> as abbreviations for <em>SORT up</em> and <em>GRADE up</em> respectively.</p>
<h2 id="reduction-transformers">Reduction Transformers</h2>
<p>The reduction of a list by an operation is the same as placing the operation between each pair of items in a list and then evaluating the resulting expression. The transformer <em>REDUCE</em> applied to a binary operation <em>f</em> implements this concept. Thus,</p>
<p><em>REDUCE f [A, B, C] = A f (B f C)</em></p>
<p>where the parentheses indicate that the grouping is to the right. For an associative operation, i.e. an operation <em>f</em> such that</p>
<p><em>(A f B) f C = A f (B f C)</em></p>
<p>the result of applying the operation between items is the same regardless of whether the grouping is to the left or to the right. However, for a non-associative operation, the result varies depending on which way the grouping is done. Thus, <em>REDUCE</em> is a right grouping reduction.</p>
<p>A related transformer is <em>ACCUMULATE</em>, which forms right grouping reductions of the initial lists of an array. For an associative operation<em>f</em>, the amount of work needed to compute</p>
<p><em>ACCUMULATE f [A, B, C]</em></p>
<p>can be lessened by using the fact that the reductions can be done with left grouping and each item in the result can be formed by one application of <em>f</em> using the preceding reduction value.</p>
<p>The operations <em>sum, product, and, or, max, min</em> and <em>link</em> are reductive by definition and are not affected by applying a reduction transformer to them. They are all associative operations when applied as a binary operation.</p>
<dl>
<dt><strong><em>REDUCE f A</em></strong></dt>
<dd><p>reduce <em>A</em> applying <em>f</em> in a right-to-left order</p>
</dd>
<dt><strong><em>ACCUMULATE f A</em></strong></dt>
<dd><p>accumulate <em>A</em> using right-to-left reductions</p>
</dd>
</dl>
<h2 id="control-structure-transformers">Control Structure Transformers</h2>
<p>One of the interesting features of Q'Nial is that it allows the user to choose a style of programming appropriate to the problem. For some purposes, an imperative style using the control structure expres sions is appropriate while for other purposes a more functional approach is simpler. Q'Nial integrates these two styles by providing transformers that have the same result as two of the control structure mechan isms. <em>ITERATE</em> is equivalent to the for-loop and <em>FORK</em> is equivalent to the if-expression.</p>
<dl>
<dt><strong><em>ITERATE f A</em></strong></dt>
<dd><p><em>f</em> is applied to the items of <em>A</em> in row major order and the result of the last application is returned</p>
</dd>
<dt><strong><em>FORK [f<sub>0</sub>, f<sub>1</sub> . . . f<sub>n</sub>] A</em></strong></dt>
<dd><p>For even values of <em>i</em> less than or equal to <em>n</em>, <em>f</em><sub><em>i</em></sub> <em>A</em> is applied sequentially until one of the results is <em>true</em>; then <em>f</em><sub><em>i+1</em></sub> <em>A</em> is returned. If no application of <em>f</em><sub><em>i</em></sub> <em>A</em> evaluates to <em>true</em>, then, if <em>n</em> is even, <em>f</em><sub><em>n</em></sub> <em>A</em> is returned; otherwise the fault <em>?noexpr</em> is returned</p>
</dd>
</dl>
<h2 id="selection-transformer">Selection Transformer</h2>
<p>There is one additional built in transformer to select items of an array based on a predicate.</p>
<dl>
<dt><strong><em>FILTER f A</em></strong></dt>
<dd><p><em>f</em> is applied to the items of <em>A</em> and the resulting boolean array is used to select items of A using sublist</p>
</dd>
</dl>
<h1 id="chapter-5-the-formal-description-of-nial-programs">Chapter 5 The Formal Description of Nial Programs</h1>
<p>Nial is a programming language specifically designed for use in an interactive environment. The formal description of the language given in this chapter describes the valid language constructs that can be entered in one interaction, and explains the meaning of one such entry in terms of the environment created by earlier inter actions in the same session. The term <strong>program fragment</strong> is used to describe a meaningful piece of program text.</p>
<p>The rules for writing well-formed program fragments in Nial are called the <strong>syntax rules</strong> of Nial. A program fragment that is well-formed is said to be syntactically correct. The syntax rules are analogous to the rules of grammar that determine the correct ness of English. Nial uses a small number of syntactic constructs that can be grouped into the following classes:</p>
<ul>
<li><p>juxtapositional forms</p></li>
<li><p>list forms</p></li>
<li><p>control structure expressions</p></li>
<li><p>parameterized functional forms</p></li>
<li><p>indexing forms</p></li>
<li><p>assignments</p></li>
<li><p>definitions</p></li>
<li><p>declarations</p></li>
</ul>
<p>These are combined using punctuation symbols and spacing to build program fragments that can be processed by the Q'Nial interpreter. The meaning of a program fragment, its <strong>semantics</strong>, is explained in terms of three classes of objects:</p>
<p><strong>arrays</strong>: the data objects</p>
<p><strong>operations</strong> : functional objects that map arrays to arrays</p>
<p><strong>transformers</strong> : functional objects that modify operations</p>
<p>The explanations are given in relationship to the global environment, which is the set of associations between names and objects formed earlier in the session; and in terms of how the objects are combined.</p>
<p>In the remainder of this chapter, the syntax of Nial is described using an extended Backus-Naur Form (BNF) formalism using the following rules:</p>
<ul>
<li><p>Symbols that appear in program fragments are in <strong>bold text</strong>.</p></li>
<li><p>A single optional form is enclosed in brackets [ ].</p></li>
<li><p>A choice between options, where one must be chosen, is written in parentheses ( ) with a vertical bar | separating choices.</p></li>
<li><p>Alternative rules for a construct are separated by the vertical bar |.</p></li>
<li><p>Fragments that can be repeated are enclosed in curly braces {}, where {} means repeated zero or more times, and {}+ means repeated one or more times.</p>
<p>In the following sections, the meaning given to a rule is given in a description following the rule.</p></li>
</ul>
<h2 id="environment">Environment</h2>
<p>Nial program fragments are entered during interactive input with a process called the <strong>top level loop</strong>; or brought into the system under the control of a systems operation, <em>loaddefs</em>. This operation has the effect of loading a sequence of program fragments from a file. The effect is as if the fragments had been entered interactively in the order they appear in the file.</p>
<p>The <strong>global environment</strong> is the collection of associations between names and objects that are known at the top level loop. Such names have <strong>global scope</strong> in that they can be referenced by any program text. All other names have a <strong>local scope</strong> that associates a meaning with the name only during execution of a specific portion of a program text.</p>
<p>A <strong>local environment</strong> is a collection of associations that are known within a limited section of program text. These limited sections are formed by <em>blocks, operation-forms</em> and <em>transformer-forms</em> as discussed in the relevant sections below. A name that has a local association in one of these forms is said to have local scope.</p>
<p>Program fragments in which local variables are being assigned can be nested, so that one local scope encloses another. A local association is not visible outside the construct in which it is defined; and a name with local scope hides associations that the name has in surrounding scopes.</p>
<p>At any point in a program fragment, there is a <strong>current environment</strong> consisting of all names whose associations are visible. It includes the names having local scope in the program fragment being executed, names that are visible in the surrounding scopes and names that have global scope.</p>
<p>In any environment, a name can have only one <strong>role</strong>: either a variable, an expression name, an operation name, a transformer name, or an identifier.</p>
<p>In program text, the scope of all names is determined by the static structure of the program text. The one exception is program text in a string that has the operation <em>execute</em> applied to it under program control. Dynamic execution of program text is described in Chapter 8.</p>
<h2 id="action">Action</h2>
<p>An <strong>action</strong> is the construct that is entered in the interactive loop of the Q'Nial interpreter or accepted as a group of lines by the operation <em>loaddefs</em>:</p>
<p>   <em>&lt;action&gt;</em> ::= <em>&lt;definition-sequence&gt;</em><br />
            | <em>&lt;expression-sequence&gt;</em><br />
            | <em>&lt;external-declaration&gt;</em><br />
            | <em>&lt;remark&gt;</em></p>
<p>If an action is a <em>&lt;definition-sequence&gt;</em>, its definitions are installed in the global environment.</p>
<p>If an action is an <em>&lt;expression-sequence&gt;</em>, it is executed and a value is returned. The value returned by an <em>&lt;expression-sequence&gt;</em> is displayed on the screen unless it is the fault <em>?noexpr</em>.</p>
<p>An <em>&lt;external-declaration&gt;</em> assigns a role to a name in the global environment so that the name can be used in other definitions before it is completely specified.</p>
<p>A <em>&lt;remark&gt;</em> is treated as commentary input and is ignored.</p>
<h2 id="definition">Definition</h2>
<p>   <em>&lt;definition-sequence&gt;</em> ::= <em>&lt;definition&gt;</em> {<strong>;</strong> <em>&lt;definition&gt;</em> } [<strong>;</strong>]</p>
<p>   <em>&lt;definition&gt;</em> ::= <em>&lt;identifier&gt;</em> <strong>IS</strong><br />
                    ( <em>&lt;simple-expression&gt;</em> | <em>&lt;operation-expression&gt;</em> | <em>&lt;transformer-expression&gt;</em> )<br />
                   | <em>&lt;comment&gt;</em></p>
<p>Every well formed program fragment that can appear on the right of the keyword <strong>IS</strong> in a definition is interpreted to be one of the three kinds of semantic objects in Nial: an array, an operation or a transformer.</p>
<p>A definition is used to associate a <strong>name</strong> (<strong>identifier</strong>) with a program fragment that is an array expression, an operation expression or a transformer expression.</p>
<p>If the definition appears within a block, the association is made in the local environment. Otherwise, the association is made in the global environment and assigns a role to the name as representing that kind of expression.</p>
<p>If the program fragment is syntactically correct, the name is associated with the program fragment in the environment and no result is given. If a syntax error is detected in the analysis of the program fragment, an explanatory fault message is returned and the name association is not made.</p>
<p>If the name being associated in a definition is already in use, the new definition must be for a construct of the same role and the earlier definition is replaced. The use of a defined name always refers to its most recent definition.</p>
<p>The name is formed according to the rules for specifying an identifier:</p>
<p>   <em>&lt;identifier&gt;</em> ::= <em>&lt;letter&gt;</em> { ( <em>&lt;letter&gt;</em> | <em>&lt;digit&gt;</em> ) }</p>
<p>   <em>&lt;letter&gt;</em> ::= <strong>&amp;</strong> | <strong>_</strong> | <strong>a</strong> | <strong>b</strong> | . . . | <strong>Y</strong> | <strong>Z</strong></p>
<p>   <em>&lt;digit&gt;</em> ::= <strong>0</strong> | <strong>1</strong> | <strong>2</strong> | . . . | <strong>9</strong></p>
<p>In Q'Nial, identifiers are limited to 80 character positions in order to facilitate the reconstruction of program text in the canonical form used in <em>see</em> and <em>defedit</em>. They may be entered in upper or lower case. Internally, Q'Nial translates the letters of an identifier to upper case so that Data, data and DATA would all be the same identifier. An identifier displayed in canonical form is presented in upper or lower case appropriate to its role. An expression or a variable is displayed with its first letter in upper case and the rest in lower case. An operation is displayed in lower case. A transformer or a reserved word is displayed in upper case.</p>
<p>Definitions in which the associated object is a simple-expression are used to name program fragments that return an array value but which do not need parameters. The resulting <em>named-expression</em> behaves like a function having no parameters.</p>
<p>An operation definition associates a name with an operation expression and results in a <em>named-operation</em>. A transformer definition associates a name with a transformer expression and results in a <em>named-transformer</em>.</p>
<p>There is no distinction in the way user-defined named objects and predefined objects are used other than the fact that predefined ones cannot be redefined in the global environment.</p>
<p>If the expression on the right of <strong>IS</strong> uses the name being defined, the definition is assumed to be recursive. The name is assigned a role compatible with its use on the right if it does not already have a role. If the expression on the right of <strong>IS</strong> is itself a named object, the name being defined is associated with the right-hand-side name rather than the expression it has as its association.</p>
<h2 id="external-declaration">External Declaration</h2>
<p>   <em>&lt;external-declaration&gt;</em> ::= <em>&lt;identifier&gt;</em> <strong>IS</strong> <strong>EXTERNAL</strong> (<br />
                              <strong>EXPRESSION</strong> | <strong>OPERATION</strong> |<br />
                              <strong>TRANSFORMER</strong> | <strong>VARIABLE</strong> )</p>
<p>An <em>external-declaration</em> assigns a role to a name, allowing it to be used in a definition before its own definition is given. This mechanism is useful for creating mutually recursive definitions. An external declaration is made only in the global environment.</p>
<p>If the name is already defined with the same role, the declaration has no effect. If the name has another role, a fault is reported. If the name is not currently defined, a default object is associated with it.</p>
<h2 id="remark">Remark</h2>
<p>   <em>&lt;remark&gt;</em> ::= <strong>#</strong> <em>&lt; any text &gt;</em></p>
<p>A <em>remark</em> is an input to the Q'Nial interpreter that is not processed. It begins with a line that has the symbol <strong>#</strong> as the first non-blank character in the line. In direct input at the top level loop, a remark ends at the end of the line unless a backslash symbol ( \ ) is used to extend the line. In a definition file, a remark ends at the first blank line. A remark cannot appear within a definition or expression-sequence. The purpose of a remark is to permit an extended textual description within a definition file for documentation purposes.</p>
<h2 id="array-expression">Array Expression</h2>
<p>An <em>array</em> is a data element of the Nial language as described in Chapter 2.</p>
<p>An <em>array-expression</em> is a well formed fragment of program text that returns an array when interpreted by Q'Nial. It is usually called an expression rather than an array-expression in this manual except in contexts where the abbreviated term might cause confusion.</p>
<p>The following sections describe how expressions are formed and what they mean. In most contexts, an <em>array-expression</em> is formed as an <em>expression-sequence</em> as described in the next section. In some contexts, however, it is limited to being to be a <em>simple-expression</em> as described in the subsequent section.</p>
<h2 id="expression-sequence">Expression Sequence</h2>
<p>An <em>expression-sequence</em> is sequence of one or more expressions separated by semicolons.</p>
<p>   <em>&lt;expression-sequence&gt;</em> ::= <em>&lt;expression&gt;</em> { <strong>;</strong> <em>&lt;expression&gt;</em> } [<strong>;</strong> ]</p>
<p>An <em>expression</em> is a <em>simple-expression</em>, a <em>comment</em>, or one of the control structure expressions.</p>
<p>   <em>&lt;expression&gt;</em> ::= <em>&lt;simple-expression&gt;</em><br />
                  | <em>&lt;assign-expression&gt;</em><br />
                  | <em>&lt;selection-expression&gt;</em><br />
                  | <em>&lt;loop-expression&gt;</em><br />
                  | <em>&lt;comment&gt;</em></p>
<p>The expressions in an <em>expression-sequence</em> are evaluated in left-to-right order. If the sequence does not terminate with a semicolon, the array returned is the result of the last expression. If the sequence does end with a semicolon, the array returned is the fault <em>?noexpr</em>. At the top level loop, if the array returned is the fault <em>?noexpr</em>, it is not displayed.</p>
<h2 id="simple-expression">Simple Expression</h2>
<p>A <em>simple-expression</em> is defined by a juxtaposition syntax involving <em>primary-expressions</em> and <em>operations</em>.</p>
<p>   <em>&lt;simple-expression&gt;</em> ::= <em>&lt;primary-sequence&gt;</em><br />
                         | <em>&lt;operation-sequence&gt;</em> <em>&lt;primary-sequence&gt;</em><br />
                         | <em>&lt;simple-expression&gt;</em> <em>&lt;simple-operation&gt;</em> <em>&lt;primary-sequence&gt;</em><br />
                         | <em>&lt;simple-expression&gt;</em> <em>&lt;simple-operation&gt;</em> <em>&lt;operation-sequence&gt;</em> <em>&lt;primary-sequence&gt;</em></p>
<p>   <em>&lt;primary-sequence&gt;</em> ::= { <em>&lt;primary-expression&gt;</em> }+</p>
<p>   <em>&lt;primary-expression&gt;</em> ::= <em>&lt;constant&gt;</em><br />
                          | <em>&lt;variable&gt;</em><br />
                          | <em>&lt;indexed-variable&gt;</em><br />
                          | <em>&lt;named-expression&gt;</em><br />
                          | <em>&lt;expression-list&gt;</em><br />
                          | <strong>(</strong> <em>&lt;expression-sequence&gt;</em> <strong>)</strong><br />
                          | <em>&lt;block&gt;</em><br />
                          | <em>&lt;cast&gt;</em></p>
<p>A <em>primary-expression</em> is a program fragment that denotes an array. If a <em>primary-sequence</em> has exactly one <em>primary-expression</em>, its value is the value of the one expression. A <em>primary-sequence</em> of length two or greater is called a <strong>strand</strong>. The value of a strand is a list of values. Each item of the list has the value of the <em>primary-expression</em> in the corresponding position in the <em>primary-sequence</em>. The value of a <em>simple-expression</em> formed by a <em>primary-sequence</em> is the value of the <em>primary-sequence</em>.</p>
<p>The value of a <em>simple-expression</em> formed by the construct <em>operation-sequence primary-sequence</em> is determined as follows: the <em>primary-sequence</em> to the right of the <em>operation-sequence</em> is evaluated, then the operations in the <em>operation-sequence</em> are applied to the result in a right-to-left order.</p>
<p>The construct <em>simple-expression simple-operation primary-sequence</em> corresponds to infix usage of a <em>simple-operation</em>. The value of a <em>simple-expression</em> formed by this construct is determined as follows: the <em>simple-expression</em> to the left is evaluated, then the <em>primary-sequence</em> to the right is evaluated; the two values are made into a pair and the result is obtained by applying the <em>simple-operation</em> to the pair. A <em>simple-expression</em> can be formed by the infix use of two or more <em>simple-operations</em> separating <em>primary-sequences</em>. The interpretation given for a single infix use just explained implies that the infix operations are used in a left-to-right order.</p>
<p>The last construct for forming a simple expression describes infix usage in the case where the program fragment after the <em>simple-operation</em> involves applying an <em>operation-sequence</em> to the <em>primary-sequence</em>. It is evaluated in a fashion similar to the rule governing the previous construct except that the <em>operation-sequence</em> is applied to the value of the <em>primary-sequence</em> prior to forming the pair.</p>
<p>The syntax rules for <em>simple-expressions</em> show three uses of the side-by-side or juxtapositional notation of Nial: strand formation, prefix operation application and infix operation application. There are no syntactic restrictions as to whether or not a particular operation may be applied in infix or prefix form. A fault is returned at run time if an operation is used inappropriately.</p>
<h2 id="primary-expressions">Primary Expressions</h2>
<p>There are several forms of primary-expressions that can form a <em>simple-expression</em>. They are described in the next few sections.</p>
<h2 id="constant">Constant</h2>
<p>A <em>constant</em> is a <em>primary-expression</em> that denotes an explicit data value. It is an array that has a fixed specific value throughout the computation and forms one syntactic unit in the formation of a strand. Constants provide a notation for constructing each of the six atomic types as well as a boolean list (bitstring) and a character list (string):</p>
<p>   <em>&lt;constant&gt;</em> ::= <em>&lt;boolean-constant&gt;</em><br />
                | <em>&lt;bitstring-constant&gt;</em><br />
                | <em>&lt;integer-constant&gt;</em><br />
                | <em>&lt;real-constant&gt;</em><br />
                | <em>&lt;character-constant&gt;</em><br />
                | <em>&lt;string-constant&gt;</em><br />
                | <em>&lt;phrase-constant&gt;</em><br />
                | <em>&lt;fault-constant&gt;</em></p>
<p>A <strong>boolean-constant</strong> is a numeric atom that repre sents a logical value.</p>
<p>   <em>&lt;boolean-constant&gt;</em> ::= <strong>l</strong> | <strong>o</strong></p>
<p>   <em>&lt;bitstring&gt;</em> ::= <em>&lt;boolean-constant&gt;</em> { <em>&lt;boolean-constant&gt;</em> }+</p>
<p>The two letters <em>l</em> and <em>o</em> are used to denote the abstract boolean values <strong>true</strong> and <strong>false</strong>, respectively. When used as numbers, they are treated as the integers 1 and 0. The names <em>True</em> and <em>False</em> are predefined named-expressions denoting the values.</p>
<p>A <em>bitstring-constant</em> denotes a list of two or more booleans, called a <strong>bitstring</strong>. A bitstring of length one is denoted by <em>[l]</em> or <em>[o]</em>.</p>
<p>An <em>integer-constant</em> is a numeric atom representing a whole number.</p>
<p>   <em>&lt;integer-constant&gt;</em> ::= [<strong>-</strong> ] { <em>&lt;digit&gt;</em> }+</p>
<p>The limits of the range of an integer number depend on the word size of the host computer. If an <em>integer-constant</em> exceeds the limit a real constant is used in its place.</p>
<p>A <em>real-constant</em> is a numeric atom that denotes a real number. A number that has a decimal point or an exponent part is a <em>real-constant</em>.</p>
<p>   <em>&lt;real-constant&gt;</em> ::= [<strong>-</strong> ] { <em>&lt;digit&gt;</em> }+ <strong>.</strong> { <em>&lt;digit&gt;</em> } [ <em>&lt;exponent&gt;</em> ]<br />
                     | [<strong>-</strong> ] { <em>&lt;digit&gt;</em> } <strong>.</strong> { <em>&lt;digit&gt;</em> }+ [ <em>&lt;exponent&gt;</em> ]<br />
                     | [<strong>-</strong> ] { <em>&lt;digit&gt;</em> }+ [ <em>&lt;exponent&gt;</em> ]</p>
<p>   <em>&lt;exponent&gt;</em> ::= (<strong>e</strong> | <strong>E</strong> ) [<strong>+</strong> | <strong>-</strong> ] { <em>&lt;digit&gt;</em> }+</p>
<p>A <em>real-constant</em> is represented by a double precision floating-point number within the computer system. It is converted to the nearest one in the floating-point number system. Because the computer has a fixed length for its representation of floating-point numbers, the precision of the number stored may be less than that specified in the constant.</p>
<p>There is one predefined <em>real-constant</em>, <strong>Pi</strong>, which is defined in <em>defs.ndf</em>.</p>
<p>A <em>character-constant</em> denotes a single atomic character; a <em>string</em> denotes a list of characters.</p>
<p>   <em>&lt;character-constant&gt;</em> ::= <strong>`</strong> <em>&lt;symbol&gt;</em></p>
<p>   <em>&lt;string-constant&gt;</em> ::= <strong>'</strong> { <em>&lt;symbol&gt;</em> }+ <strong>'</strong></p>
<p>where <em>symbol</em> is a member of the set of characters for the host system.</p>
<p>A <em>character-constant</em> denotes a literal atom that can be represented on the keyboard, on the screen or on the printer of the computer by a single symbol. The set of characters for Q'Nial is determined by the host system. On most systems, the 128 characters of the ASCII character set are represented in the stan dard way. On some systems, an additional 128 characters are available for special use. The ordering sequence of the characters for sorting purposes is fixed for each Q'Nial version.</p>
<p>There is one character-constant predefined in <em>defs.ndf</em> called <strong>Separator</strong>. It has the value <strong>/</strong> on UNIX and OSX systems. It is useful for building path names for host files on these systems.</p>
<p>A <em>string-constant</em> denotes a list of zero or more characters. A string-constant is denoted by a sequence of zero or more symbols bounded by single quote marks. A pair of adjacent single quote marks within the bounding ones denotes a single quote mark in the resulting list.</p>
<p>The remaining two constant constructs denote literal atoms that are phrases or faults.</p>
<p>   <em>&lt;phrase-constant&gt;</em> ::= <strong>&quot;</strong> { <em>&lt;non-terminating-symbol&gt;</em> }</p>
<p>   <em>&lt;fault-constant&gt;</em> ::= <strong>?</strong> { <em>&lt;non-terminating-symbol&gt;</em> }</p>
<p>where <em>non-terminating-symbol</em> is a member of the set <em>symbols</em> excluding the characters:</p>
<p>   &lt;blank&gt; <strong>(</strong> <strong>)</strong> <strong>[</strong> <strong>]</strong> <strong>{</strong> <strong>}</strong> <strong>#</strong> <strong>,</strong> <strong>;</strong></p>
<p>The excluded symbols are omitted in <em>phrase-constants</em> and <em>fault-constants</em> because they tend to be punctuation symbols which naturally end a phrase. Omitting them avoids easily created errors. A phrase or fault containing the excluded symbols can be created using the operations <em>phrase</em> or <em>fault</em>, respectively, each taking a string as argument.</p>
<p>A <em>phrase-constant</em> denotes an atomic literal that is treated as a unit. Phrases are stored uniquely in an internal table and represented by an internal pointer. Comparisons of phrases for equality are as efficient as integer comparisons since only the internal pointers are compared.</p>
<p>A <em>fault-constant</em> denotes an atomic literal that is used to represent an erroneous or extraordinary result. Faults are very similar to phrases but are treated differently by the non-structural operations in order to propagate error reporting information. A fault indicates the type of error or condition detected. All faults produced by Q'Nial begin with a question mark.</p>
<p>Not all faults indicate errors; some signal special values. The fault <em>?eof</em>, for example, indicates the end of an input file.</p>
<p>In the default mode of operation of Q'Nial, most fault values are not created. Rather, an interrupt is triggered. A description of the fault triggering mechanism is given in Chapter 9.</p>
<h2 id="variable">Variable</h2>
<p>A <em>variable</em> is a name associated with an array value. Its syntactic form is that of an identifier.</p>
<p>   <em>&lt;variable&gt;</em> ::= <em>&lt;identifier&gt;</em><br />
              | <em>&lt;identifier&gt;</em> <strong>:</strong> <em>&lt;identifier&gt;</em></p>
<p>A variable is given an association with an array value by its use on the left side of an assign-expression, its appearance in a <em>local</em> or <em>nonlocal</em> declaration, its designation as a variable in an external-declaration or its use as the first argument of the operation <em>assign</em>.</p>
<p>When a variable is used as a <em>primary-expression</em>, its meaning is the array value associated with the identifier. If the variable exists but has not been assigned, it will have as its default value the fault <em>?no_value</em>. If an identifier is mentioned as a primary-expression but has not yet been given an association, a parse error will occur with the fault <em>?undefined identifier:</em>.</p>
<p>The second form of variable is used to refer to a variable in a scope that has invoked the scope in which the form appears. It is useful in debugging situations where the value of variables in the calling environment need to be examined. The first identifier refers to the name of the definition and the second to the variable in scope of the definition.</p>
<p>A variable gives a name to the result of a computation. If the same result is needed later in the program, the named variable can be used, thereby avoiding the necessity of repeating the computation. A variable can be assigned different array values throughout the computation.</p>
<p>Although an identifier can be of any length up to 80 characters, a compromise is usually made between choosing explicit variable names and choosing brief names to avoid unnecessary typing. An identifier used as a variable cannot be a <em>reserved word</em>. (A table of the reserved words is given in the <em>Nial Dictionary</em> under <strong>reserved words</strong>.) In a local environment, a variable identifier can be chosen the same as a predefined or user-defined global definition name. Such a choice makes the global use of the name unavailable in the local context.</p>
<p>In any environment, an identifier can name only one of: a variable, an array-expression, an operation-expression, or a transformer-expression. During one session, the <em>role</em> of a global identifier, i.e. the class of syntactic object it names, cannot be changed.</p>
<h2 id="scope-of-a-variable">Scope of a Variable</h2>
<p>The use of an assign-expression indicates that a name (identifier) is to be treated as a variable in the context surrounding the assign-expression. This context is called the <strong>scope</strong> of the variable. The context may be global, in which case the variable may be visible at all levels; or it may be local to some region of program text. A local scope is created for the parameters of operation forms and for variables created within a block.</p>
<p>Because operation forms or blocks may appear within other operation forms or blocks, it is possible to have one scope for a name nested within another. A name is said to be visible at a point in a program text if it has a local meaning at that point or has a meaning in some surrounding scope or is a global name. When a name is used in a local scope, it is the local association in the innermost scope that is used, instead of an association with the same name in a surrounding scope.</p>
<h2 id="indexed-variable">Indexed Variable</h2>
<p>An <em>indexed variable</em> is a variable for which a part of the associated array value is referenced:</p>
<p>   <em>&lt;indexed-variable&gt;</em> ::= <em>&lt;variable&gt;</em> <strong>@</strong> <em>&lt;primary-expression&gt;</em><br />
                        | <em>&lt;variable&gt;</em> **@<span class="citation">@*</span>* <em>&lt;primary-expression&gt;</em><br />
                        | <em>&lt;variable&gt;</em> <strong>#</strong> <em>&lt;primary-expression&gt;</em><br />
                        | <em>&lt;variable&gt;</em> <strong>|</strong> <em>&lt;primary-expression&gt;</em></p>
<p>An <em>index</em> is the value of the primary-expression within an indexed-variable which specifies the location or locations of the part or parts of the array that are selected.</p>
<p>If an indexed-variable is used as a primary-expression, its value is the value of the selected part of the variable. There are four ways to index an array in Nial as described in the following table:</p>
<table style="width:110%;">
<colgroup>
<col width="19%" />
<col width="15%" />
<col width="29%" />
<col width="45%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Symbol Type</th>
<th align="left">Name</th>
<th align="left">Index</th>
<th align="left">Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">@</td>
<td align="left">at</td>
<td align="left">address</td>
<td align="left">item at the address</td>
</tr>
<tr class="even">
<td align="left">@@</td>
<td align="left">at-path</td>
<td align="left">path</td>
<td align="left">part at the path</td>
</tr>
<tr class="odd">
<td align="left">#</td>
<td align="left">at-all</td>
<td align="left">array of addresses</td>
<td align="left">the array of items at the addresses</td>
</tr>
<tr class="even">
<td align="left">|</td>
<td align="left">slice</td>
<td align="left">positions on axes</td>
<td align="left">cross sections of items</td>
</tr>
</tbody>
</table>
<p>Nial uses zero-origin indexing, so that the first item in a list is at address 0 and the first item in a table is at address (0 0). When the indexed-variable notation is interpreted, the primary-expression is evaluated. The result of the evaluation of the primary-expression and the form of indexing together determine the locations specified by the particular indexed-variable notation. If the primary-expression does not evaluate to a valid index for the array and the type of indexing, a fault is returned.</p>
<p>In the <em>at</em> form of indexing, the result is the item at the given address of the array associated with the variable.</p>
<p>In the <em>at-path</em> form of indexing, the value of the index is a list of addresses for subparts of the array on a path descending into the nesting structure of the array. The notation refers to the value of an item of an item etc. for as many levels as the length of the path.</p>
<p>In the <em>at-all</em> form of indexing, the index is an array of addresses. An array of the same shape as the index is selected from the array associated with the variable, with items chosen using the index items as addresses.</p>
<p>In the <em>slice</em> form of indexing, the index is a list of arrays, each array representing the positions to be chosen for one of the axes of the array being indexed. There must be as many items in the index as there are axes. If an item of the index is the fault <em>?noexpr</em> (usually generated using an expression-list with a missing position) that entry is expanded to be the list of all positions on that axis. The cartesian product of the expanded index is then used to form an array of addresses, which are used to select the corresponding items as in <em>at-all</em> indexing. The <strong>cartesian product</strong> of a list of arrays is an array of lists containing all the combinations formed by taking one item from each of the arrays in turn. It is implemented by the same algorithm used for the operation <em>cart</em>.</p>
<p>The shape of the result of slice indexing is found by linking the shapes of the items of the expanded index.</p>
<h2 id="named-expression">Named Expression</h2>
<p>   <em>&lt;named-expression&gt;</em> ::= <em>&lt;identifier&gt;</em></p>
<p>A *named-expression** is an array-expression that is associated with a name by being predefined or through a definition. The use of a named-expression in a primary-expression causes the associated expression to be executed when the primary-sequence in which it is embedded is evaluated. Each mention of the name causes the expression to be evaluated.</p>
<h2 id="expression-list">Expression List</h2>
<p>   <em>&lt;expression-list&gt;</em> ::= <strong>[</strong> <em>&lt;expression-comma-sequence&gt;</em> <strong>]</strong><br />
                       | <strong>[</strong> <em>&lt;expression-comma-sequence&gt;</em> <em>&lt;simple-expression&gt;</em> <strong>]</strong></p>
<p>   <em>&lt;expression-comma-sequence&gt;</em> ::= <em>&lt;expression-comma-sequence&gt;</em> <strong>,</strong><br />
                       | <em>&lt;expression-comma-sequence&gt;</em> <em>&lt;simple-expression&gt;</em> <strong>,</strong><br />
                       | <em>&lt;empty&gt;</em></p>
<p>The value of an expression-list is a list of the length of the number of simple-expressions in the expression list, counting expressions omitted before or after a comma. The items of the result are the values of the simple-expressions evaluated and sequenced in left-to-right order. If there are no items in the expression list, the result is <em>Null</em>, the predefined empty list.</p>
<p>An expression can be missing before or after a comma. The value corresponding to a missing expression is the no-expression fault: <em>?noexpr</em>. An expression-list containing omitted expressions is useful in providing an index for the <em>at-slice</em> form of indexing.</p>
<p>A list may be constructed directly by using brackets notation or strand notation. In <strong>brackets-comma notation</strong>, the elements of a list are separated by commas and the list is bounded by square brackets. In <strong>strand notation</strong>, the elements of a list are separated by one or more blank spaces. Parentheses can be used with strand notation for grouping two or more items as a strand that forms a sublist of the list denoted by the strand notation. Extra parentheses are ignored in strands.</p>
<p>A list may contain arrays of any type in any sequence desired. Both strand and brackets notation may occur in the same list. A list in brackets notation is one unit in the construction of a list using strand notation. Strand notation can be used to create a list with two or more items. Brackets notation can be used to create a list with no items, one item, or many items.</p>
<h2 id="parenthesized-expression-sequence">Parenthesized Expression Sequence</h2>
<p>The value of a <em>parenthesized expression-sequence</em> is the value of the expression-sequence. The parenthe ses indicate that the expression-sequence is evaluated before inclusion in a further computation. This use of parentheses is consistent with their use in mathematical notation. An expression-sequence can be made into a primary-expression by enclosing it in parenthe ses.</p>
<h2 id="block">Block</h2>
<p>   <em>&lt;block&gt;</em> ::= <strong>{</strong> [ <strong>LOCAL</strong> { <em>&lt;identifier-sequence&gt;</em> }+; ]<br />
                [ <strong>NONLOCAL</strong> { <em>&lt;identifier-sequence&gt;</em> }+; ]<br />
                [ <em>&lt;definition-sequence&gt;</em> <strong>;</strong> ]<br />
                <em>&lt;expression-sequence&gt;</em><br />
             <strong>}</strong></p>
<p>A <em>block</em> is a scope-creating mechanism that permits an expression-sequence to be created so that it has local definitions and variables which are visible only inside the block. A block may appear as a primary-expression or as the body of an operation-form.</p>
<p>If a block is used as a primary-expression, the local environment created by a block is determined by the block itself. If it is the body of an operation-form, the local environment includes the formal parameter names of the operation-form as variables.</p>
<p>The value of a block is the value of the expression-sequence within the block, evaluated within the local context formed by the declarations and definitions within the block, if any.</p>
<h2 id="local-and-nonlocal-declaration">Local and Nonlocal Declaration</h2>
<p>The identifiers included in the <em>local</em> and <em>nonlocal</em> declarations are declared to be variables. Both forms of declarations are optional, but if both are given, local declarations must be made first. If the block is the body of a globally defined operation-form or expression, a nonlocal declaration effectively declares its variables as global ones.</p>
<p>A block delimits a local environment. It allows new uses of names which do not interfere with uses of those names outside the block. For example, within a block, a predefined operation name can be redefined and used for a different purpose. Only the reserved words of Q'Nial cannot be reused in this fashion.</p>
<p>Definitions that appear within the block have local scope. That is, the definitions can be referenced only in the body of the block. Variables assigned within the block may or may not have local scope, depending on the appearance of a local and/or a nonlocal declaration. If there is no declaration, all assigned variables have local scope. Declaring some variables as local does not change the effect on undeclared variables that are used on the left of assignment; they are automatically localized.</p>
<p>If a nonlocal declaration is used, an assigned name that is on the nonlocal list is sought in surrounding scopes. If the name is not found, a variable is created in the global environment.</p>
<p>The determination of the scope of a variable is done when the program fragment in which it is located is analysed. The same scope is then used each time the fragment is evaluated.</p>
<h2 id="nested-definition">Nested Definition</h2>
<p>A <em>nested definition</em> is one that appears in a definition sequence within a block. The defined name is local to the block. If the name is also used outside the block, the external meaning is not known in the block.</p>
<p>Nested definitions can be used to encapsulate supporting definitions within a larger definition that is to be made available to other users. This avoids cluttering up the name space with names that might interfere with the user's other work. It is often easier to develop the large definition without encapsulation and package it in encapsulated form once the design is completed.</p>
<h2 id="cast">Cast</h2>
<p>A <strong>cast</strong> is an array that denotes an internal representation of a valid fragment of Q'Nial program text:</p>
<p>   <em>&lt;cast&gt;</em> ::= <strong>!</strong> <em>&lt;identifier&gt;</em><br />
            | <strong>!</strong> ( <em>&lt;expression-sequence&gt;</em> )<br />
            | <strong>!</strong> ( <em>&lt;operation-expression&gt;</em> )<br />
            | <strong>!</strong> ( <em>&lt;transformer-expression&gt;</em> )</p>
<p>The use of the exclamation symbol ( <strong>!</strong> ) before an identifier causes Q'Nial to select the internal represen tation for the identifier rather than the value of the array associated with the identifier. Its use before a parenthesized program fragment selects the internal representation of the program fragment. The internal representation is a nested array forming the parse tree of the construct.</p>
<p>The major use of casts is in conjunction with the operations <em>assign</em> and <em>apply</em>. These operations mimic the Q'Nial constructs for assignment to a variable and application of an operation to an array. Casts permit passing an argument to an operation by variable name rather than by value. They also permit evaluation of a program fragment that has been stored in its internal form using the operation <em>eval</em> rather than requiring the use of the operation <em>execute</em> on the corresponding program text stored as a string. The details of the internal representation is not specified as part of the Nial language.</p>
<p>The description of the syntactic construct <em>simple-expression</em> is now complete.</p>
<h2 id="assign-expression">Assign Expression</h2>
<p>   <em>&lt;assign-expression&gt;</em> ::= { variable }+ <strong>:=</strong> <em>&lt;expression&gt;</em><br />
                         | <em>&lt;indexed-variable</em>&gt; <strong>:=</strong> <em>&lt;expression</em>&gt;</p>
<p>An <strong>assign-expression</strong> assigns an array value to one or more variables at the time of evaluation of the assign expression. The semantics of an assign expression is interpreted in two stages: when the expression is analysed (parsed) and when it is executed.</p>
<p>During the parse of an assign-expression appearing in a block, each name on the variable list is sought in the local environment. If the name exists in the local environment, the assignment affects the local association. If a name does not exist in the local environment and no reference has been made to a nonlocal variable with the same name, a local variable is created in the block and the association is with this new variable. An assign-expression parsed in the global environment creates a global variable if a variable with that name does not already exist.</p>
<p>When an assign expression is executed, the expression on the right of the assignment symbol ( <em>:=</em> ) is evaluated. If the variable list on the left has only one name, the value of the expression is assigned to that variable. That is, the value is associated with that name.</p>
<p>If the variable list has several names, the items of the value are assigned to the variables in the order in which they appear. If the number of items does not match the number of variables, the fault <em>?assignment</em> is returned as the value of the assign-expression. Otherwise, the value of the assign-expression is the value of the expression on the right.</p>
<p>When an indexed-variable is used on the left in an assign-expression, the parts of the array associated with the variable at the locations specified by the index are replaced by the values of the expression on the right.</p>
<p>If the index expression for an indexed-variable assignment specifies a number of locations (at-all or slice indexing), there are two cases: if the value on the right is a single, the item of the single is placed in each location; otherwise, the value on the right must have the same number of items as the index expres sion indicates and the corresponding locations are updated with the items of the array value.</p>
<p>The keyword <strong>GETS</strong> is a synonym for the assignment symbol <em>:=</em> .</p>
<h2 id="selection-expression">Selection Expression</h2>
<p><strong>Selection-expressions</strong> are used to describe computations in which one of many actions or values is to be evaluated.</p>
<p>   <em>&lt;selection-expression&gt;</em> ::= <em>&lt;if-expression&gt;</em><br />
                            | <em>&lt;case-expression&gt;</em></p>
<p>   <em>&lt;if-expression&gt;</em> ::= <strong>IF</strong> <em>&lt;simple-expression&gt;</em> <strong>THEN</strong><br />
                        <em>&lt;expression-sequence&gt;</em><br />
                     { <strong>ELSEIF</strong> <em>&lt;simple-expression&gt;</em> <strong>THEN</strong> <em>&lt;expression-sequence&gt;</em> }<br />
                     [ <strong>ELSE</strong> <em>&lt;expression-sequence&gt;</em> ]<br />
                     <strong>ENDIF</strong></p>
<p>   <em>&lt;case-expression&gt;</em> ::= <strong>CASE</strong> <em>&lt;simple-expression&gt;</em> <strong>FROM</strong><br />
                         { <em>&lt;constant&gt;</em> <strong>:</strong> <em>&lt;expression-sequence&gt;</em> <strong>END</strong> }+<br />
                         [ <strong>ELSE</strong> <em>&lt;expression-sequence&gt;</em> ]<br />
                       <strong>ENDCASE</strong></p>
<p>In the <strong>if-expression</strong> the selection is made by evaluating the simple-expressions after the <em>if</em> and <em>elseif</em> keywords as boolean expressions. As soon as one of these evaluates to <em>true</em>, the expression-sequence following the corresponding <em>then</em> is evaluated and its value returned as the result of the if-expression.</p>
<p>All the simple-expressions after the <em>if</em> and <em>elseif</em> may evaluate to <em>false</em>. If they do and an <em>else</em> is pre sent, the result is the value of the expression-sequence following the <em>else</em>. If all the simple-expressions after the <em>if</em> and <em>elseif</em> evaluate to <em>false</em> and there is no <em>else</em> present, the result is the fault <em>?noexpr</em>. If one of the simple-expres sions evaluates to a non-boolean value, the result is the fault <em>?L</em>.</p>
<p>In the <strong>case-expression</strong>, the selection is made by evaluating the simple-expression following the <em>case</em> and comparing it to the constants preceding the colons. If the value matches a constant, the expression-sequence following the corresponding colon is returned as the result of the case-expression. If the value does not match one of the constants, the result returned by the case-expression is the value of the expression-sequence following the <em>else</em> if it is present; otherwise the result is the fault <em>?noexpr</em>.</p>
<p>The case-expression form of selection is useful when the choice depends on a single atomic value and there are a large number of possible values the simple-expression can take on.</p>
<p>Both of these forms can be used in a value oriented way or as an imperative. If the desired effect is to return a value, each expression-sequence must omit the final semicolon so that if it is selected, its value rather than the fault <em>?noexpr</em> is returned.</p>
<h2 id="loop-expression">Loop Expression</h2>
<p><strong>Loop expressions</strong> are used to repeat a computation a number of times. In the three forms of loops, the computation is in the form of a loop-body. This is an expression-sequence as described above with the additional property that it, or expression-sequences embedded within it, can use the exit-expression as an additional form of expression.</p>
<p>   <em>&lt;loop-expression&gt;</em> ::= <em>&lt;for-expression&gt;</em><br />
                       | <em>&lt;while-expression&gt;</em><br />
                       | <em>&lt;repeat-expression&gt;</em><br />
   <em>&lt;for-expression&gt;</em> ::= <strong>FOR</strong> <em>&lt;variable&gt;</em> <strong>WITH</strong> <em>&lt;simple-expression&gt;</em> <strong>DO</strong><br />
                           <em>&lt;loop-body&gt;</em><br />
                       <strong>ENDFOR</strong></p>
<p>   <em>&lt;while-expression&gt;</em> ::= <strong>WHILE</strong> <em>&lt;simple-expression&gt;</em> <strong>DO</strong><br />
                            <em>&lt;loop-body&gt;</em><br />
                        <strong>ENDWHILE</strong></p>
<p>   <em>&lt;repeat-expression&gt;</em> ::= <strong>REPEAT</strong><br />
                            <em>&lt;loop-body&gt;</em><br />
                         <strong>UNTIL</strong><br />
                            <em>&lt;simple-expression&gt;</em><br />
                         <strong>ENDREPEAT</strong></p>
<p>   <em>&lt;exit-expression&gt;</em> ::= <strong>EXIT</strong> <em>&lt;simple-expression&gt;</em></p>
<p>In the <strong>for-expression</strong>, the simple-expression evalua tes to an array value used to control the loop. The loop-body is evaluated repeatedly with the variable taking on the items of the control array in turn. If the control array is empty, the loop-body is not evaluated.</p>
<p>A <strong>while-expression</strong> implements a loop with a pretest. The simple-expression and the loop-body are evaluated alternately as long as the simple-expression evaluates to a boolean value and is <em>true</em>. If the simple-expression is <em>false</em> on the first evaluation, the loop-body is not executed.</p>
<p>A <strong>repeat-expression</strong> implements a loop with a post test. The loop-body and the simple-expression are evaluated alternately until the simple-expression evaluates to a boolean value and is <em>true</em>. If the simple-expression is <em>true</em> on the first evaluation, the loop body is executed once.</p>
<p>In all three loop forms, if an embedded exit-expression is evaluated, the loop terminates early and returns with the value of the simple-expression following the reserved word <em>exit</em>. The exit-expression cannot be used outside a loop-expression.</p>
<p>The value of a loop expression in all three cases is the value of the expression-sequence on the last evaluation of the loop body. If the loop body is never evaluated, the value is the fault: <em>?noexpr</em>. In the last two forms, if the simple-expression does not return a boolean, the value of the loop is the logical fault <em>?L</em>.</p>
<h2 id="comment">Comment</h2>
<p>   <em>&lt;comment&gt;</em> ::= <strong>%</strong> <em>&lt;any text excluding a semicolon&gt;</em> <strong>;</strong></p>
<p>A <strong>comment</strong> is a brief section of text included in a program fragment to assist readability. Comments may be placed anywhere in a block before or after declarations, definitions or expressions. Their purpose is to provide an explanation of the program fragment for the programmer who may be required to modify the definition at a later date. The value of a comment as an expression is the <em>?noexpr</em> fault. Comments are retained when a definition is translated into internal form and they appear in its creation in the canonical form used by the operations <em>see</em> and <em>defedit</em>.</p>
<p>The description of the construct <em>expression</em> is now complete. The next three sections describe the constructs for <em>operation-expression</em>.</p>
<h2 id="operation-expression">Operation Expression</h2>
<p>Q'Nial has a large number of predefined operations chosen both for their generality and for their practical utility in a wide variety of applications. Programming in Nial is achieved by defining new operations and using them to carry out a required computation. The following sections describe the program fragments that can be used as operation-expressions.</p>
<p>   <em>&lt;operation-expression&gt;</em> ::= <em>&lt;operation-sequence&gt;</em><br />
                            | <em>&lt;operation-form&gt;</em><br />
                            | <em>&lt;curried-operation&gt;</em></p>
<p>   <em>&lt;operation-sequence&gt;</em> ::= { <em>&lt;simple-operation&gt;</em> }+</p>
<p>   <em>&lt;curried-operation&gt;</em> ::= <em>&lt;simple-expression&gt;</em> <em>&lt;simple-operation&gt;</em></p>
<p>The result of applying an <strong>operation-sequence</strong> to an argument is determined by applying the simple-opera tions in the sequence in right-to-left order.</p>
<p>The simple-operation on the right is applied to the argument giving an intermediate result. Then the simple-operation to the immediate left is applied to the result of the first application. Subsequent simple-operations are applied to the results in turn.</p>
<p>Thus, the effect of applying an operation-sequence of two or more simple-operations to an argument is equivalent to the effect of applying the <strong>functional composition</strong> of the operations to the argument. (The word <em>effect</em> is used in this explanation because the application of an operation to an array will always produce a <em>result</em>; but some operations produce a <em>side-effect</em> such as, for example, writing a record to a file.)</p>
<p>The result of applying a <strong>curried-operation</strong> is determined by applying the simple-operation to the pair formed from the value of the simple-expression and the argument to the curried-operation.</p>
<h2 id="simple-operation">Simple Operation</h2>
<p>   <em>&lt;simple-operation&gt;</em> ::= <em>&lt;named-operation&gt;</em><br />
                        | <em>&lt;atlas&gt;</em><br />
                        | <em>&lt;transform&gt;</em><br />
                        | <strong>(</strong> <em>&lt;operation&gt;</em> <strong>)</strong></p>
<p>   <em>&lt;named-operation&gt;</em> ::= <em>&lt;identifier&gt;</em></p>
<p>A <strong>named-operation</strong> is a predefined operation or an operation that is associated with a name through a definition.</p>
<p>An operation does not need to be named. It can be created and used in place without being named. However, except for very brief operation-expressions, the normal procedure is to give an operation-expres sion a name using the definition mechanism.</p>
<p>When a predefined operation is applied to an argument, the algorithm implied by the description of the operation (given briefly in Part 2, or in more detail in the <em>Nial Dictionary</em>) is followed.</p>
<p>The effect of applying a user-defined operation is equivalent to the effect of evaluating the program text fragment with the following change: the occurrence of the name of the user-defined operation is replaced by the operation-expression ( possibly in parentheses if context requires it) which is associated with the user-defined operation name.</p>
<p>An operation can be viewed as a black box with input and output. The argument is the input to the operation and the result is the output. The application of the operation may also produce side effects if the operation does input or output operations or if assignments are made to variables that are declared to be nonlocal.</p>
<p>   <em>&lt;atlas&gt;</em> ::= <strong>[</strong> <em>&lt;operation-expression&gt;</em> { <strong>,</strong> <em>&lt;operation-expression&gt;</em> } <strong>]</strong></p>
<p>An <strong>atlas</strong> is an operation made up of a list of component operations. The result of applying an atlas is a list of the same length as the atlas. Each operation in the atlas is applied in turn to the argument resulting in an array value that becomes the item of the result list in the corresponding position.</p>
<p>   <em>&lt;transform&gt;</em> ::= <em>&lt;named-transformer&gt;</em> <em>&lt;simple-operation&gt;</em></p>
<p>A <strong>transform</strong> is a simple-operation formed by modifying a given simple-operation. This is done by placing a transformer name before the given simple-operation. An operation-expression that is not a simple-operation can be modified by placing it in parentheses.</p>
<p>The result of the modification denotes a new operation. This new operation is called a transform. When the transform is applied to an array, the operation that is part of the transform is used in the evaluation of the result in the manner determined by the transformer.</p>
<p>A transformer usually specifies a general algorithm which can have one or more operations as parameters. For example, the <em>EACH</em> related transformers generalize a number of looping mechanisms for applying an operation to items of arrays.</p>
<p>A user-defined transformer could provide the skeleton for processing the records of a file and allow an arbitrary operation to be applied to each record.</p>
<p>If a transform is formed using a named-operation, it is the <em>name</em> of the operation to which the transform is bound. The transform is not bound to any specific definition of the operation. Thus, a subsequent redefinition of the named-operation will change the meaning of the transform.</p>
<p>Any operation-expression is made into a simple-operation by enclosing it within parentheses. A simple-operation formed by parenthesizing an operation-sequence returns the same result as the operation-sequence. Parenthesized operations permit curried operations to appear within an operation-sequence and allow compositions of operations to be an argument of a transformer.</p>
<h2 id="operation-form">Operation Form</h2>
<p>   <em>&lt;operation-form&gt;</em> ::= <strong>OPERATION</strong> { <em>&lt;identifiers&gt;</em> }+ <em>&lt;block&gt;</em><br />
                      | <strong>OPERATION</strong> { <em>&lt;identifiers&gt;</em> }+ <strong>(</strong> <em>&lt;expression-sequence&gt;</em> <strong>)</strong></p>
<p>An <strong>operation-form</strong> is the syntactic structure used to describe an operation in terms of a parameterized expression-sequence. The identifiers following the keyword <em>operation</em> are called the <strong>formal parameters</strong>. The <strong>body</strong> of an operation-form is normally a block but it may be an expression-sequence in parentheses without automatic localization.</p>
<p>An operation-form defines a local environment. The formal parameter names are names of local variables. If the body of the operation form is a block, the local environment of the block is extended to include the formal parameters.</p>
<p>When the operation-form is applied, the formal parameter names are assigned from the value of the actual argument. If there is only one formal parameter, the actual argument is assigned to it as a whole; otherwise, the items of the actual argument are assigned to the formal parameters in corresponding order. If there is a length mismatch between the list of formal parameter names and the values of the actual argument, the fault <em>?op_parameter</em> is returned.</p>
<p>The value of the application of the operation is the value of the body of the operation-form, which is evaluated with the local variables in the parameter list assigned as described above. In determining the association for a name that appears in the body of an operation form, Q'Nial looks for the name in the local environment. If the name is not found locally, the name is sought in surrounding environments until it is found or until the global environment is searched. If it is not found, a fault <em>?unknown identifier</em> is given when the operation-form is translated to internal form (parsed).</p>
<p><em>Operation-forms</em> are most frequently used in definitions where they are given an associated name. However, an operation-form can appear directly in an expression provided it is enclosed in parentheses. In this usage, it can be an argument to a transformer name or can be applied to an array argument.</p>
<p>The description of the construct <em>operation-expression</em> is now complete.</p>
<h2 id="transformer-expression">Transformer Expression</h2>
<p>A <strong>transformer</strong> is a functional object in Nial which, when applied to an operation, forms a new operation called a transform. Transformers provide a systematic way of modifying or generalizing operations. Q'Nial provides a number of predefined transformers that have proven useful in extending the expressive power of the language. A mechanism is provided to extend Nial with user defined transformers.</p>
<p>Applying a transformer has no action associated with it other than capturing the environment where it is applied to an argument operation. When the resulting transform is applied, the captured environment is used as the environment in which to invoke the argument operation when it is used within the algorithm of the transformer.</p>
<p>   <em>&lt;transformer-expression&gt;</em> ::= <em>&lt;named-transformer&gt;</em><br />
                              | <em>&lt;transformer-form&gt;</em></p>
<p>   <em>&lt;named-transformer&gt;</em> ::= <em>&lt;identifier&gt;</em></p>
<p>A <strong>named-transformer</strong> is one associated with a name by a definition or is a predefined transformer. A transformer cannot be used without being given a name. A predefined transformer modifies its operation argument according to the algorithm given in its description.</p>
<p>A user defined transformer has the effect of the named-transformer expression with which it is associated. A transformer definition associates a name with a transformer-form or with another transformer name. In the latter case, it is the name of the other transformer that is bound not the trans former-expression defined by the other transformer.</p>
<h2 id="transformer-form">Transformer Form</h2>
<p>   <em>&lt;transformer-form&gt;</em> ::= <strong>TRANSFORMER</strong> { <em>&lt;identifier&gt;</em> }+ <em>&lt;operation-form&gt;</em><br />
                        | <strong>TRANSFORMER</strong> { <em>&lt;identifier&gt;</em> }+ <strong>(</strong> <em>&lt;operation-expression&gt;</em> <strong>)</strong></p>
<p>A <strong>transformer-form</strong> is the syntactic structure used to describe a transformer in terms of an operation expression involving formal operation parameters. The names that follow the keyword <em>TRANSFORMER</em>in the transformer-form are called <strong>formal operation parameters</strong>. The body of a transformer-form is the operation-expression which uses these names. The first construct requires that the operation-expression be an operation-form; the second allows any operation-expression enclosed in parentheses to be used.</p>
<p>The effect of applying a transformer-form to an operation-expression is the effect of the operation formed from the body of the transformer, such that wherever one of the formal operation parameters occurs, it is replaced with the corresponding argument operation-expression. If there is only one parameter then its occurrences are replaced by the argument. If there is more than one parameter then the operation-expression must be an atlas of the same length and the formal parameters are replaced by the corresponding operations of the argument atlas. If there is a mismatch between the number of formal operation parameters and the argument, the result of applying the transform is the fault <em>?tr_parameter</em>.</p>
<p>The associations are made with the argument opera tion-expression in the environment where the trans former is applied. Thus, if the transformer is recursive, the formal parameter may have a different association on each recurrence.</p>
<h2 id="summary-of-juxtapositional-syntax">Summary of Juxtapositional Syntax</h2>
<p>The following table summarizes the uses of juxtaposition in Nial, where A and B are array-expressions, f and g are operation expressions, and T is a transformer</p>
<table>
<thead>
<tr class="header">
<th align="left">Form</th>
<th align="left">Name</th>
<th align="left">Object Class</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">A B</td>
<td align="left">strand</td>
<td align="left">array</td>
</tr>
<tr class="even">
<td align="left">A f</td>
<td align="left">currying</td>
<td align="left">operation</td>
</tr>
<tr class="odd">
<td align="left">f A</td>
<td align="left">prefix use</td>
<td align="left">array</td>
</tr>
<tr class="even">
<td align="left">f g</td>
<td align="left">composition</td>
<td align="left">operation</td>
</tr>
<tr class="odd">
<td align="left">T f</td>
<td align="left">transform</td>
<td align="left">operation</td>
</tr>
<tr class="even">
<td align="left">A f B</td>
<td align="left">infix use</td>
<td align="left">array</td>
</tr>
<tr class="odd">
<td align="left">T f A</td>
<td align="left">transform use</td>
<td align="left">array</td>
</tr>
</tbody>
</table>
<p>An informal description of the rules for parsing the juxtapositional forms is given in Chapter 3 of Part 1 of the Manual.</p>
<h2 id="synonyms">Synonyms</h2>
<p>The <strong>synonyms</strong> given below abbreviate typing for interactive use or avoid difficulties with some termi nals on older compu ter systems that do not support the full character set used in the syntax rules. The following synonyms are available for keywords or delimiters used in the syntax rules:</p>
<table>
<thead>
<tr class="header">
<th align="left">Usual</th>
<th align="left">Alternate</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">[</td>
<td align="left">&lt;&lt;</td>
</tr>
<tr class="even">
<td align="left">]</td>
<td align="left">&gt;&gt;</td>
</tr>
<tr class="odd">
<td align="left">:=</td>
<td align="left">GETS</td>
</tr>
<tr class="even">
<td align="left">{</td>
<td align="left">BEGIN</td>
</tr>
<tr class="odd">
<td align="left">}</td>
<td align="left">END</td>
</tr>
<tr class="even">
<td align="left">OPERATION</td>
<td align="left">OP</td>
</tr>
<tr class="odd">
<td align="left">TRANSFORMER</td>
<td align="left">TR</td>
</tr>
</tbody>
</table>
<h1 id="chapter-6-file-input-and-output-operations">Chapter 6 File Input and Output Operations</h1>
<p>Q'Nial includes operations to create and manipulate files of textual information, to communicate with devices as read/write files and to provide direct access to component files holding arrays or strings. The files are stored externally to the workspace using the mechanisms of the host system.</p>
<h2 id="sequential-files">Sequential Files</h2>
<p>A sequential file corresponds to a sequence of lines of text with lines separated by an end-of-line indicator. The files are read and written in units of lines which are converted to and from Nial strings. A sequential file is opened for read, write, append, communications or as a pipe.</p>
<p>The sequential file capabilities are:</p>
<dl>
<dt><strong><em>open Fn Mode</em></strong></dt>
<dd><p>Open file <em>Fn</em> in mode <em>Mode</em> and return an integer file number <em>F</em>.</p>
</dd>
<dt><strong><em>close F</em></strong></dt>
<dd><p>Close the file designated by <em>F</em></p>
</dd>
<dt><strong><em>readfile F [N]</em></strong></dt>
<dd><p>If N is missing, return a string holding one record from the file designated by <em>F</em>, omitting the end of line indication; otherwise, return <em>N</em> characters from the file <em>F</em> including end of line characters; or return a fault <em>?eof</em> indicating end of file.</p>
</dd>
<dt><strong><em>writefile F A [M]</em></strong></dt>
<dd><p>Write character array <em>A</em> to the file designated by <em>F</em>. If <em>M</em> is <em>true</em> or missing, write the end of line indica tion; if <em>M</em> is <em>false</em>, do not write the end of line indication.</p>
</dd>
<dt><strong><em>getfile Fn</em></strong></dt>
<dd><p>Obtain all the records of file <em>Fn</em> as a list of strings.</p>
</dd>
<dt><strong><em>putfile Fn S</em></strong></dt>
<dd><p>Write strings <em>S</em> to the file <em>Fn</em>.</p>
</dd>
<dt><strong><em>appendfile Fn S</em></strong></dt>
<dd><p>Append strings <em>S</em> to end of file <em>Fn</em>.</p>
</dd>
<dt><strong><em>Filestatus</em></strong></dt>
<dd><p>Return a list of triples giving the file number, filename and mode of use of each open file.</p>
</dd>
</dl>
<p>A filename is specified by a phrase or a string. The name is given to the operation <em>open</em> along with a mode indication given by the following table</p>
<table>
<thead>
<tr class="header">
<th align="left">Indicator</th>
<th align="left">Open Mode</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><em>&quot;r</em></td>
<td align="left">read</td>
</tr>
<tr class="even">
<td align="left"><em>&quot;w</em></td>
<td align="left">write</td>
</tr>
<tr class="odd">
<td align="left"><em>&quot;a</em></td>
<td align="left">append</td>
</tr>
<tr class="even">
<td align="left"><em>?c</em></td>
<td align="left">communications</td>
</tr>
<tr class="odd">
<td align="left"><em>?pr</em></td>
<td align="left">pipe read</td>
</tr>
<tr class="even">
<td align="left"><em>?pw</em></td>
<td align="left">pipe write</td>
</tr>
<tr class="odd">
<td align="left"><em>?d</em></td>
<td align="left">direct access</td>
</tr>
</tbody>
</table>
<p>A file number, used in all subsequent operations on the file, is returned. A file opened in read mode can be used only for input with the operation <em>readfile</em>. A file opened in write or append mode can be used only for output with the operation <em>writefile</em>. Write mode creates a new file; append mode opens an existing file at the end, so that additional records can be written to it. If the file does not exist when <em>open</em> is used, append mode is equi valent to write mode.</p>
<p>A file must be open to be used by <em>readfile</em> or <em>writefile</em>. Fault <em>?eof</em> is returned if an attempt is made to read beyond the end of the file. If the second argument to <em>writefile</em> is a table, one record is written for each row of the table.</p>
<p>Communication mode assumes that the file is being used for both reading and writing. The version of <em>readfile</em> in which a number of characters can be specified, provides the low level control of the reading process. The version of <em>writefile</em> in which no end of line control is added, allows control over the charac ters transmitted to a communications device.</p>
<p>Pipe read and pipe write modes are used for executing a host command that either reads the result of the execution using <em>readfile</em> or provides input to the execution using <em>writefile</em>. The command is given as a string in place of the file name. See the discussion of the operation host in Chapter 9.</p>
<p>The operations <em>getfile</em> and <em>putfile</em> are intended for use on relatively small files in which all the data can be held in the workspace. <em>Getfile</em> is equivalent to opening the file in read mode, reading all its records and then closing the file. <em>Putfile</em> is the similar composite opera tion for the writing process.</p>
<p>The first three file numbers are used as follows:</p>
<table>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">stdin</td>
<td align="left">the standard input stream</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">stdout</td>
<td align="left">the standard output stream</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">stderr</td>
<td align="left">the error output stream</td>
</tr>
</tbody>
</table>
<p>Thus, <em>readfile 0</em> accepts input from the keyboard, and <em>writefile 1 Data</em> sends the string <em>Data</em> to the display screen. These are useful for testing out a file-oriented program during debugging.</p>
<h2 id="qnial-specific-direct-access-file-operations">Q'Nial Specific Direct Access File Operations</h2>
<p>Q'Nial supports a component style of direct access to binary files in two forms: files in which the components are alphanumeric records that are treated as Nial character strings; and files in which the components are representations of arbitrary array values.</p>
<p>The same underlying mechanism is used to support both forms of direct access files. The direct access files are Q'Nial specific but use the host system files for their representation. Two files are used: a record file given the extension <em>.rec</em> and an index file given the extension <em>.ndx</em>.</p>
<p>It is possible to treat an externally created file as a <em>record</em> direct file provided it is named appropriately and a suitable index file is created.</p>
<p>A direct access file is prepared for use by calling the operation <em>open</em> with a file name without an extension and the mode indication <em>&quot;d</em>. If the two corresponding host files exist, they are opened. If they do not exist they are created and initialized.</p>
<p>The kind of direct access file is determined by the first write operation applied to it. The use of <em>writearray</em> creates a file of array components, whereas the use of <em>writerecord</em> creates a file of record components. All subsequent read and write accesses to the direct access file must be of the same kind.</p>
<p>The operations that support direct access files are described as follows</p>
<dl>
<dt><strong><em>open Fn &quot;d</em></strong></dt>
<dd><p>Open the file <em>Fn</em> for direct access and return an integer.</p>
</dd>
<dt><strong><em>filetally F</em></strong></dt>
<dd><p>Return the highest component number in the file designated by integer <em>F</em>.</p>
</dd>
<dt><strong><em>readrecord F N</em></strong></dt>
<dd><p>Return string component <em>N</em> of the file designated by integer <em>F</em>.</p>
</dd>
<dt><strong><em>readarray F N</em></strong></dt>
<dd><p>Return array component <em>N</em> from the file designated by integer <em>F</em>.</p>
</dd>
<dt><strong><em>writerecord F N B</em></strong></dt>
<dd><p>Write the string <em>B</em> to component <em>N</em> of the file designated by integer <em>F</em>.</p>
</dd>
<dt><strong><em>writearray F N B</em></strong></dt>
<dd><p>Write the array <em>B</em> to component <em>N</em> of the file designated by integer <em>F</em>.</p>
</dd>
<dt><strong><em>eraserecord F N</em></strong></dt>
<dd><p>Erase component <em>N</em> in the file designated by integer <em>F</em>.</p>
</dd>
</dl>
<p>In the above operations, <em>N</em> can be a list of component numbers. For a read, the corresponding list of components is obtained. For a write, <em>B</em> must be a corresponding number of components to be written. The components can be read or written in any order. Note that using an integer with the read operation returns the component as the result, and using a solitary integer, a list with one integer, returns a solitary list with the component as the item.</p>
<p>There is no requirement that all the component numbers below the number returned by <em>filetally F</em> be in use. If there is no component at a position specified in <em>N</em> in a <em>readarray</em>, the result is the fault <em>?missing</em>. For <em>readrecord</em>, the result is the empty string. The result in both operations is the fault <em>?eof</em> if <em>N</em> is greater than the result of <em>filetally F</em>. In a <em>writearray</em> of <em>writerecord</em> operation, if <em>N</em> is greater than or equal to <em>filetally F</em>, then the record is written and the <em>filetally</em> is increased to one higher than <em>N</em>. Note that the index file used to implement direct access files has an entry for each possible record and hence leaving huge gaps in the record numbers can waste a substantial amount of space.</p>
<p><em>Eraserecord</em> is used for both kinds of files. If the component removed is the last one, any components immediately preceding it that are not in use are also removed and the filetally is adjusted accordingly. For a file of records it is not possible to distinguish between an unused record and a record consisting of an empty string.</p>
<p>In the write operations, if a component already exists, its value is replaced. The physical host file used to hold the components is not necessarily in the same order as the component numbers. As components are overwritten, their previous space is used if possible, otherwise the information is appended to the end of the <em>.rec</em> file. For fixed length components, the order of the components is not changed because of an update.</p>
<p>As components of a direct access file are rewritten out of place because of increased size, or as they are erased, unused space accumulates in the <em>.rec</em> file. A record is maintained on the amount of unused space in the file and, after every write or erase, if the unused space has become significant relative to the size of the file, an automatic compression process is executed which rebuilds the file so that the components are in index order.</p>
<p>It is possible to use Q'Nial to access files created by another process. To do this, the file must be renamed to have the extension <em>.rec</em> and an index file that is appropriate to the data structure within the file must be built. If the file has a logical structure of fixed size that repeats, the index file need have only as many records as make up one unit of the logical structure. If the record number used in a <em>readrecord</em> is above <em>filetally</em>, the record file is checked to see if the file extends beyond the length indicated by the <em>filetally</em>. If so, the file is assumed to consist of a sequence of blocks of records of the same structure as indicated in the index file and the record selected is determined by <em>N mod filetally F</em>.</p>
<h2 id="direct-access-operations-for-host-files">Direct Access Operations for Host Files</h2>
<p>Q'Nial also provides operations that can access the raw byte data of files on the host system. In these operations the name of the file is used as the argument and file open and closes are done implicitly.</p>
<dl>
<dt><strong><em>readfield Fnm P N</em></strong></dt>
<dd><p>Return <em>N</em> bytes of the file <em>Fnm</em> starting at position <em>P</em> as a string.</p>
</dd>
<dt><strong><em>writefield Fnm P S</em></strong></dt>
<dd><p>Write the string <em>S</em> to the file named <em>Fnm</em> at position <em>P</em>.</p>
</dd>
<dt><strong><em>filelength Fnm</em></strong></dt>
<dd><p>Return the number of bytes in the file named <em>Fnm</em>.</p>
</dd>
</dl>
<p>The direct access operations for host files are useful in applications where pre-existing files need to be accessed or modified under program control. The <em>readfield</em> operation can be used to read in any portion of a file as a string without interpretation of newline characters. If the position plus the length requested is greater than the filelength the fault <em>?eof</em> is returned.</p>
<p>The operation <em>writefield</em> can write a string of any length to any position in a file. If it is written in a position beyond the current file length, the intervening space may be filled with arbitrary data. If the file does not exist, <em>writefield</em> will create it.</p>
<h1 id="chapter-7-operations-for-the-interpreter-mechanisms">Chapter 7 Operations for the Interpreter Mechanisms</h1>
<p>Q'Nial has operations that provide direct access by the user to most of the underlying mechanisms that support the evaluation of Nial constructs. These operations behave like most other operations in Q'Nial but they are dependent on the internal representations used in the Q'Nial implementation and may not produce identical results from one version to another. They should not be considered part of the Nial language; rather, they are extensions made specifically in the Q'Nial implementation.</p>
<h2 id="top-level-loop">Top Level Loop</h2>
<p>Q'Nial7 is implemented as an interactive program running on a console or in a terminal emulation window. The direct input to the interpreter mechanism is a string representing Nial program text. The execution of the text is carried out in a three stage process. First, the string is scanned to produce a list of tokens that represent the component parts of the text. The result is a list beginning with a Token Stream Tag (the number 99) and followed by an alternating sequence of integer codes and phrases.</p>
<p>There is no limitation on the size of tokens corresponding to the literal types. That is, a constant token for a literal string, phrase or fault can be as long as required for an application. However, identifiers are stored only up to a maximum length of 80 characters. The following segments from a log of a session illustrate the top level loop mechanism:</p>
<pre><code>set &quot;decor;
Token_list := scan &#39;A := 3*5.2&#39;
99 2 &quot;A 1 &quot;:= 16 &quot;3 2 &quot;* 18 &quot;5.2</code></pre>
<p>The codes for tokens used by scan are:</p>
<table>
<thead>
<tr class="header">
<th align="left">Code</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">reserved word or delimiter</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">identifier</td>
</tr>
<tr class="odd">
<td align="left">14</td>
<td align="left">string</td>
</tr>
<tr class="even">
<td align="left">15</td>
<td align="left">phrase</td>
</tr>
<tr class="odd">
<td align="left">16</td>
<td align="left">integer</td>
</tr>
<tr class="even">
<td align="left">18</td>
<td align="left">real number</td>
</tr>
<tr class="odd">
<td align="left">22</td>
<td align="left">fault</td>
</tr>
<tr class="even">
<td align="left">42</td>
<td align="left">atomic character</td>
</tr>
<tr class="odd">
<td align="left">40</td>
<td align="left">atomic boolean or bitstring</td>
</tr>
</tbody>
</table>
<p>To select the token pairs from the result of <em>scan</em>, the following expression is used:</p>
<pre><code>Token_pairs := lo cutall rest Token_list
+----+-----+-----+----+-------+
|2 &quot;A|1 &quot;:=|16 &quot;3|2 &quot;*|18 &quot;5.2|
+----+-----+-----+----+-------+</code></pre>
<p>To test which tokens are constants, the comparison is:</p>
<pre><code>EACH first Token_pairs &gt; 2
oolol</code></pre>
<p>The last token pair represents a real number:</p>
<pre><code>Realtoken := last Token_pairs
18 &quot;5.2</code></pre>
<p>The value of a constant token pair can be obtained by executing the string of the token or by using parse as described below:</p>
<pre><code>tonumber second Realtoken
5.2</code></pre>
<p>The second stage of executing the string of text is called the parsing stage. The token list is processed and a nested array that represents the structure of the expression denoted by the text is returned. The resulting data structure is a pair: the first item is a Parse Tree tag (the number 100), indicating that the data structure represents a parse data structure; the second item is a nested list of lists where each list is a node of the parse tree for the expression. Each node of the parse tree has an integer tag as the first item to indicate the type of construct that the node represents. The remaining items of a node are themselves nodes of the corresponding components of the construct or represent constants or names:</p>
<pre><code>Parse_tree := parse Token_list

+---+------------------------------------------------------------+
|100|+-+--------------------------------------------------------+|
|   ||9|+--+-----------------+---------------------------------+||
|   || ||13|+--+------------+|+--+----------+------+----------+|||
|   || ||  ||22|2 7670 43248|||49|3 1 3 82 1|1 3 &quot;3|1 5.2 &quot;5.2||||
|   || ||  |+--+------------+|+--+----------+------+----------+|||
|   || |+--+-----------------+---------------------------------+||
|   |+-+--------------------------------------------------------+|
+---+------------------------------------------------------------+</code></pre>
<p>In the above example, the tags have the meanings described in the following table:</p>
<table>
<thead>
<tr class="header">
<th align="left">Tag</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">100</td>
<td align="left">parse tree</td>
</tr>
<tr class="even">
<td align="left">9</td>
<td align="left">expression sequence</td>
</tr>
<tr class="odd">
<td align="left">13</td>
<td align="left">assignment expression</td>
</tr>
<tr class="even">
<td align="left">22</td>
<td align="left">variable list</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">variable</td>
</tr>
<tr class="even">
<td align="left">49</td>
<td align="left">binary operation application</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">basic operation</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">constant</td>
</tr>
</tbody>
</table>
<p>The parse trees are not intended for modification or for examination by program control. They provide an effective representation for expressions that can be used for evaluation or for recovery of the textual form as described below.</p>
<p>However, they can be used in simple ways such as converting a constant token to its value. For example, to get the value corresponding to <em>Realtoken</em> we can form the corresponding parse tree by:</p>
<pre><code>parse (99 hitch Realtoken)

+---+--------------+
|100|+-+----------+|
|   ||9|1 5.2 &quot;5.2||
|   |+-+----------+|
+---+--------------+</code></pre>
<p>The real number can be selected by</p>
<pre><code>R := second second parse (99 hitch Realtoken)
5.2</code></pre>
<p>The third stage in the execution of the string of text is the evaluation stage. The evaluation is done by recursively &quot;walking&quot; the parse tree and evaluating each construct according to the semantic rules of Q'Nial:</p>
<pre><code>eval Parse_tree
15.6</code></pre>
<p>We have illustrated that a string containing a Nial array expression can be evaluated by the composition of *eval**, parse* and <em>scan</em>, which is how the operation <em>execute</em> is defined:</p>
<pre><code>execute IS eval parse scan
execute &#39;A := 3 \* 5.2&#39;
15.6</code></pre>
<p>It is not intended that users understand or manipulate the internals of parse tree representations of con structs. Q'Nial has few safeguards if <em>eval</em> is applied to data structures that are not created directly by the interpreter itself.</p>
<p>In order to reduce the need for users to deal with parse trees, Q'Nial has a method to obtain the internal representation of a valid construct. This is the <strong>cast</strong> array-expression, designated by placing an exclamation mark before the construct.</p>
<p>Q'Nial also has operations to recover the textual form from the internal representation. The operations <em>deparse</em> and <em>descan</em> accomplish this in two steps: <em>deparse</em> converts a parse tree to a token stream that has a few extra token symbols to indicate indentation and line breaks and <em>descan</em> converts a token stream into a list of strings. For example:</p>
<pre><code>New_token_list := deparse Parse_tree
99 2 &quot;A 1 &quot;:= 16 &quot;3 2 &quot;\* 18 &quot;5.2
Link descan New_token_list
&#39;A := 3 \* 5.2 &#39;</code></pre>
<p>When <em>descan</em> and <em>deparse</em> are applied to the parse trees for array expressions with control constructs such as <em>if-expressions</em> and <em>for-expressions</em>, the result is a list of lines which when written provide the construct in an indented form. In addition, all identifiers appear with their use encoded as follows:</p>
<table>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Canonical Form</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">variable</td>
<td align="left">First letter upper case, the rest lower case</td>
</tr>
<tr class="even">
<td align="left">expression</td>
<td align="left">First letter upper case, the rest lower case</td>
</tr>
<tr class="odd">
<td align="left">operation</td>
<td align="left">all lower case</td>
</tr>
<tr class="even">
<td align="left">transformer</td>
<td align="left">all upper case</td>
</tr>
<tr class="odd">
<td align="left">reserved word</td>
<td align="left">all upper case</td>
</tr>
</tbody>
</table>
<p><strong>Figure 8-3 Canonical Form for Nial Identifiers</strong></p>
<p>The operation:</p>
<pre><code>canonical IS link descan deparse parse scan</code></pre>
<p>provides a canonical string representation for any valid Nial action, in the sense that for such a string <em>S</em>, the two following identities hold:</p>
<pre><code>canonical canonical S = canonical S
execute canonical S = execute S</code></pre>
<p>The first identity states that the <em>canonical</em> operation has no effect on a string already in canonical form. The second states that the canonical form of an action has the same meaning as the action itself.</p>
<p>The <em>deparse</em> and <em>descan</em> operations are used by <em>defedit</em> to transform the parse tree of a definition to textual form. They are also accessed implicitly in the operation <em>see</em>.</p>
<p>The evaluation operations:</p>
<dl>
<dt><strong><em>scan A</em></strong></dt>
<dd><p>The token stream corresponding to the string <em>A</em> as a program fragment.</p>
</dd>
<dt><strong><em>parse A</em></strong></dt>
<dd><p>The parse tree corresponding to token stream <em>A</em>.</p>
</dd>
<dt><strong><em>eval A</em></strong></dt>
<dd><p>The value obtained by evaluating a parse tree, cast or a named array expression <em>A</em>.</p>
</dd>
<dt><strong><em>deparse A</em></strong></dt>
<dd><p>Canonical token stream corresponding to parse tree <em>A</em>.</p>
</dd>
<dt><strong><em>descan A</em></strong></dt>
<dd><p>The list of strings corresponding to token stream <em>A</em>.</p>
</dd>
<dt><strong><em>execute A</em></strong></dt>
<dd><p>The value derived by executing the string <em>A</em> as a program fragment.</p>
</dd>
</dl>
<p>For console versions the top level loop of Q'Nial is informally described by:</p>
<pre><code>EndSignal := false ;
Prompt := &#39; &#39; ;
WHILE not EndSignal DO
X := eval parse scan readscreen Prompt ;
IF X \~= ??noexpr THEN
writescreen picture X ;
ENDIF
ENDWHILE</code></pre>
<p>where it is assumed that the expressions <em>Bye</em> and <em>Continue</em> will set the variable <em>EndSignal</em> to <em>True</em>. Also this version of a top level loop does not implement the use of ?]? to capture the last value computed. A loop is easily written for an application to use a different prompt or a different convention with respect to output of the results of computations. In this way, the Q'Nial interpreter can be tailored for different styles of use.</p>
<h2 id="picture-operations">Picture Operations</h2>
<p>The five operations described below give access to the picture drawing capabilities.</p>
<dl>
<dt><strong><em>picture A</em></strong></dt>
<dd><p>The character table that is the picture of <em>A</em> with the current mode settings. In the picture of <em>A</em>, all non-atomic arrays are left justified and numeric atoms are right justified.</p>
</dd>
<dt><strong><em>sketch A</em></strong></dt>
<dd><p>The picture of <em>A</em> in the form that it takes when the mode switches are set to diagram and nodecor.</p>
</dd>
<dt><strong><em>diagram A</em></strong></dt>
<dd><p>The picture of <em>A</em> in the form it takes when diagram mode is set and the decor mode uses its current setting.</p>
</dd>
<dt><strong><em>display A</em></strong></dt>
<dd><p>A string which, when executed, returns <em>A</em>.</p>
</dd>
<dt><strong><em>paste Sw A</em></strong></dt>
<dd><p>A character table constructed by pasting an array <em>A</em> of character tables together according to the settings in switch <em>Sw</em> for vertical edge spacing, horizontal edge spacing, vertical line switch, horizontal line switch, vertical justification indicator and horizontal justification indicator.</p>
</dd>
<dt><strong><em>positions A</em></strong></dt>
<dd><p>The array of addresses in the picture of A where each item of A is placed.</p>
</dd>
</dl>
<p>The <em>paste</em> operation is used internally by the <em>picture</em> operation. <em>Paste</em> allows a programmer to produce non-standard pictures of arrays.</p>
<p>The justification indicator is an array of the shape of <em>A</em>, with integer codes for each item; or a single integer code applicable to all items. The justification codes are 0, 1 and 2 for left or top, centred and right or bottom respectively.</p>
<p>The vertical edge spacing is an integer indicating the number of blank lines between rows of items. The horizontal edge spacing is an integer indicating the number of blank spaces between columns of items. The line switch is 1 to draw lines, or 0 to suppress lines.</p>
<h2 id="phrases-names-and-casts">Phrases, Names and Casts</h2>
<p>The names used in Q'Nial in forming associations are represented internally as phrases. The associations are stored in arrays called <strong>symbol tables</strong> that record the environment in which the name is used and its role in that environment.</p>
<p>Q'Nial uses two different mechanisms to refer to names at the scan and parse levels. At the scan level a name is a phrase, which has to be looked up in the correct environment by examining the symbol tables in an appropriate order while parsing the tokens. After the parse is done, a name is denoted by a parse tree that points to its symbol table entry. The cast notation <em>!Name</em> is used to denote the parse tree that represents the name. Note that at the top level , parentheses must be included around the use of the cast notation, e.g. (<em>!Name</em>), to avoid ambiguity with the use of ! to indicate a host command.</p>
<p>Both representations of names are useful. The phrase is readable. It is looked up in the symbol tables in the context where it is used and hence refers to the object in a <strong>dynamic</strong> way. The cast, because it is analyzed in the context in which it appears, refers to a variable or definition in a <strong>static</strong> way.</p>
<p>Q'Nial contains operations that mimic the underlying meaning of variables, expressions and operations in Q'Nial. The operations use strings, phrases or casts to represent the name of the object under consideration (except that <em>see</em> and <em>getdef</em> do not take casts).</p>
<dl>
<dt><strong><em>value A</em></strong></dt>
<dd><p>Return the value of a variable nam ed by string, phrase or cast <em>A</em>.</p>
</dd>
<dt><strong><em>A assign B</em></strong></dt>
<dd><p>Assign the array <em>B</em> to the variable named by string, phrase or cast <em>A</em>; return <em>B</em>.</p>
</dd>
<dt><strong><em>A apply B</em></strong></dt>
<dd><p>Apply the operation named by string, phrase or cast <em>A</em> to array <em>B</em>; re turn the result of the operation.</p>
</dd>
<dt><strong><em>getdef A</em></strong></dt>
<dd><p>Return the parse tree associated with the definition name by string or phrase <em>A</em>.</p>
</dd>
<dt><strong><em>see A</em></strong></dt>
<dd><p>Display the definition named by the stri ng or phrase <em>A</em>.</p>
</dd>
<dt><strong><em>update P A B</em></strong></dt>
<dd><p>Put array <em>B</em> at address <em>A</em> in the array associated with the vari able named by the phrase, string or cast <em>P</em>; return the new value of the array.</p>
</dd>
<dt><strong><em>updateall P A B</em></strong></dt>
<dd><p>Put items of <em>B</em> at addresses <em>A</em> in the array associated with the variable named by the phrase, string or cas <em>P</em>; return the new value of the array.</p>
</dd>
<dt><strong><em>deepupdate P A B</em></strong></dt>
<dd><p>Put array <em>B</em> at path <em>A</em> in the array associated with the variable named by the string, phrase or cast <em>P</em>; return new value of the array.</p>
</dd>
<dt><strong><em>getname A</em></strong></dt>
<dd><p>Converts a parse tree symbol table reference A (a triple) to the corresponding name.</p>
</dd>
<dt><strong><em>getsyms Nm</em></strong></dt>
<dd><p>Gets the parameters and local variables of definition Nm.</p>
</dd>
</dl>
<p><em>Assign</em> mimics the behaviour of <em>gets</em> or <em>:=</em> but does it dynamically. The left argument to <em>assign</em> is a phrase, string or a cast naming the variable to be changed or crea ted. The major difference between the operation <em>assign</em> and assigning using the <em>:=</em> construct is that the former occurs entirely during program execution, whereas the latter has a translation stage in which the scope of the variable name is determined and then an execution phase when the assignment is done. One effect of the difference is that a <em>new</em> variable created by the operation <em>assign</em> is always placed in the global environment. Another difference is that the operation <em>assign</em> does not have the restriction that the phrase or string obey the lexical rule for an identifier and hence it is possible to build associations that do not interfere with variables in the program text.</p>
<p>An important use of <em>assign</em> is to mimic a <strong>by-variable</strong> form of parameter passing in place of Nial's <strong>by-value</strong> form. The result depends on what kind of name is provided, a phrase or a cast. If the name is provided as a phrase, the variable that is selected is determined by <em>assign</em> when it does the assignment by looking first in the local environment and then in the surrounding ones. If the name is provided as a cast, the variable selected is the one that exists at the point where the cast is formed. Thus, by-variable parameter passing is achieved by using the cast of the variable as an argument in the call; whereas in the body of the operation the formal parameter is assigned using <em>assign</em> and evaluated using <em>value</em>.</p>
<p>The operation <em>apply</em> mimics the application of an operation to an array. The operation to be applied is provided as a phrase or a cast. One use of apply is to provide a dynamic switch, where the operation to be applied is selected from a list using <em>pick</em> and then applied with <em>apply</em>.</p>
<p>The operation <em>see</em> writes the canonical form of a definition to the terminal screen. The character table is displayed as if:</p>
<pre><code>ITERATE writescreen descan deparse getdef Defnm</code></pre>
<p>were executed with <em>sketch</em> and <em>nodecor</em> display modes. It does not affect the settings of the display modes.</p>
<p>The operations <em>update, updateall</em> and <em>deepupdate</em> mimic the indexed assignment notations for *at**, at-all* and <em>at-path</em> indexing. They are provided to allow selective updating of global variables with no copying.</p>
<p>The operations <em>getname</em> and <em>getsyms</em> are provided for detailed parse tree analysis and are not intended for general use.</p>
<p>Operations that give user access to the internal mechanisms should be used with due recognition that they may make programs implementation dependent.</p>
<h2 id="dynamic-execution-of-name-associations">Dynamic Execution of Name Associations</h2>
<p>The operation <em>execute</em> can be used within the execution of a block to make an assignment to variables or to invoke the definition mechanism. If <em>execute</em> is used to make a new definition or to create a new variable, the resulting variable or definition is placed in the global environment. However, if the block has local variables or local definitions, <em>execute</em> can be used to change a local version dynamically. A similar situation occurs with dynamic alteration of variables using <em>assign</em>.</p>
<h1 id="chapter-8-management-of-the-programming-environment">Chapter 8 Management of the Programming Environment</h1>
<p>The topics in this chapter describe aspects of the programming environment for Q'Nial that are common to all versions.</p>
<h2 id="the-qnial-programming-environment">The Q'Nial Programming Environment</h2>
<p>When Q'Nial is invoked, an area of memory is set aside for use during the interactive session. This area is called the <strong>active workspace</strong>. It holds all the definitions and variables that are created during a session. The size of the workspace can grow as more space is required as long as system space is available.</p>
<p>After initialization, Q'Nial begins interaction, by entering a top level loop. It accepts program text interactively and executes it. Definitions and variables are created by entering actions interactively or by reading in a program text file using <em>loaddefs</em>.</p>
<p>The active workspace can be saved and restarted at a later time. It can be cleared or reset to its status at the beginning of the session. A Q'Nial session ends when either <em>Bye</em> or <em>Continue</em> is executed.</p>
<h2 id="invoking-qnial">Invoking Q'Nial</h2>
<p>There are a number of command line options in invoking the console version of Q'Nial which provide flexibility for its use in applications. A Q'Nial session is invoked by the command:</p>
<pre><code>Nial</code></pre>
<p>It has the following syntax:</p>
<pre><code>Nial [(+\-)size Wssize] [-defs Filename] [-lws WSFilename] [-i] [-h]</code></pre>
<p>The parameters are shown within brackets [ ] to indicate that they are all optional. The order of the parameters does not matter. The meanings of the parameters are as follows:</p>
<dl>
<dt><strong><em>Wsname</em></strong></dt>
<dd><p>The named workspace is loaded instead of the <em>clearws.nws</em> file that is normally entered or created on invocation. The workspace can contain a <em>Latent</em> expres sion and hence can trigger an applica tion. This feature gives direct control over where to start the work. If no name is given, Q'Nial looks for file <em>co tinue.nws</em> in the current directory. If it exists, the session is started with it rather than the clear workspace.</p>
</dd>
<dt>*** (+|-)size Wssize***</dt>
<dd><p>This option begins Q'Nial with a workspace of <em>Wssize</em> words. <em>Wssize</em> is an integer (.&gt;= 50000) with a possible suffix of M for megawords or K for kilowords. If <em>+size Wssize</em> is used, the workspace size is fixed at the specified size. If an operation cannot complete with the given size, a jump to the top level occurs with the message:</p>
<p>Warning: workspace full Returning to top level.</p>
</dd>
<dt><strong><em>-defs Filename</em></strong></dt>
<dd><p>After loading the starting workspace and executing its <em>Latent</em> expression if any, the definition file <em>Filename.ndf</em> is loaded using the <em>loaddefs</em> operation. The effect is equivalent to executing the expression <em>loaddefs</em> <em>Filename</em> when the first prompt is given. The definitions are not displayed when loaded. If the <em>Latent</em> expression enters an interaction loop, the file is not loaded until the loop terminates.</p>
</dd>
<dt><strong><em>-i</em></strong></dt>
<dd><p>Run Q'Nial in interactive mode</p>
</dd>
<dt><strong><em>-h</em></strong></dt>
<dd><p>display the help information for invoking Q?Nial.</p>
</dd>
</dl>
<p>The options for invoking Q'Nial can be used in the following ways:</p>
<ol style="list-style-type: decimal">
<li><p>During application development, the part of an application that is stable could be stored in a workspace, say <em>appl.nws</em>, and the current defini tions being debugged could be in <em>newdefs.ndf</em>. A system script file (.bat under MS-DOS) having the following line could be used to enter Nial with everything loaded:</p>
<p><em>nial -defs newdefs appl</em></p></li>
<li><p>An application could be tailored for particular use by loading a predefined set of definitions using the <em>Wsname</em> or the <em>-defs</em> Filename options.</p></li>
<li><p>Q'Nial could be used as a filter that executes a program silently and then quits could be invoked with the following linewhere the expression <em>Bye</em> is placed at the end of file <em>Filename.ndf</em>. The actions in the file are executed but the top level loop is not entered.</p>
<p><em>nial -q -defs Filename</em></p></li>
</ol>
<p>If the -q option is not used, a banner message such as the following is displayed:</p>
<pre><code>Q&#39;Nial V7.0 Open Source Edition Intel x86 64bit Linux Feb 21 2016
Copyright (c) NIAL Systems Limited
clear workspace created</code></pre>
<p>If none of the <em>-defs, Filename</em> or <em>Wsname</em> options is used, the <em>clearws.nws</em> workspace is loaded. If the <em>clearws.nws</em> file does not exist in the current directory, it is sought in the <em>nialroot</em> directory. If it is not present in either place, it is created automatically by the initialization process and kept internal to Q'Nial. Once the initial workspace has been made, it can be saved using:**</p>
<pre><code>save &quot;clearws</code></pre>
<p>When the clear workspace is loaded, the default prompt of five blank characters is displayed and the cursor is placed at the sixth position.</p>
<p>Q'Nial views its input as a stream from the standard input file <em>stdin</em>. This means that a file of actions can be piped to Q'Nial to use Q'Nial as a filter. One side effect of this design is that one can end a Q'Nial session in the console versions by giving it the end of file signal interactively. On Unix systems by &lt;Ctrl d&gt;. Terminating a Q'Nial session in this manner is equivalent to using <em>Bye</em> and hence the current workspace is not saved.</p>
<h2 id="naming-the-latest-result">Naming the Latest Result</h2>
<p>Q'Nial retains the result of the most recent interaction. To give the last value computed a name, eg. <em>Var</em>, the right bracket symbol ( <strong>]</strong> ) is followed by the variable name.</p>
<pre><code>]Var</code></pre>
<h2 id="session-related-expressions-and-operations">Session Related Expressions and Operations</h2>
<p>There are a number of operations that assist in workspace management, managing program development, interfacing with host facilities and debugging.</p>
<h2 id="restarting-a-qnial-session">Restarting a Q'Nial Session</h2>
<p>During a session, to start over with the workspace restored to its original contents, one of the expressions <em>Restart</em> or <em>Clearws</em> is used.</p>
<dl>
<dt><strong><em>Restart</em></strong></dt>
<dd><p>Reset the active workspace to have the same content as that provided when Q'Nial was invoked and retun to top level.</p>
</dd>
<dt><strong><em>Clearws</em></strong></dt>
<dd><p>Reset the active workspace to be cleared of all user defined variables and definitions.</p>
</dd>
</dl>
<h2 id="ending-a-qnial-session">Ending a Q'Nial Session</h2>
<p>A session on Q'Nial is ended by the execution of one of the following expressions:</p>
<dl>
<dt><strong><em>Bye</em></strong></dt>
<dd><p>End the session of Q'Nial and return to the host operating system. Information in the current workspace is lost.</p>
</dd>
<dt><strong><em>Continue</em></strong></dt>
<dd><p>Save the workspace as <em>continue.nws</em> in the current directory; end the session of Q'Nial and return control to the host operating system. The workspace is restored in the next session started from the same directory using the invocation of <em>nial</em> without the <em>Ws name</em> option from the same direc tory.</p>
</dd>
</dl>
<p>The continue workspace is a convenience for short term saving of current work. If a session that was started from a continue workspace is ended by using <em>Bye</em>, the file <em>continue.nws</em> is deleted.</p>
<h2 id="interrupts-and-error-recovery">Interrupts and Error Recovery</h2>
<p>There are certain invalid computations or resource limitations that prevent Q'Nial from continuing with a computation. A message is displayed when such situations arise. Q'Nial can normally return to the top level loop when errors of this type occur. It calls the user-defined operation <em>recover</em> (if it exists) after cleaning up all the temporary values existing when the error occurred. The recovery may take a few seconds if there is extensive cleanup of temporary values to be done.</p>
<p>In the definition of an operation or expression, a situation may occur which is best handled by interrupting the computation and returning control to the interaction loop. There are also situations when recovery is needed to prevent returning to the interaction loop. The expression Toplevel causes a return to top level.</p>
<p>Q'Nial permits interruption of a computation by using an interrupt signal that is host system dependent. The interrupt signal is &lt;Ctrl c&gt; on most console versions of Q'Nial.</p>
<p>A user initiated interrupt is equivalent to execution of <em>Toplevel</em>. When such an interrupt occurs and <em>recover</em> is present, <em>recover</em> is executed. Interrupts can be inhibited using the operation <em>setinterrupts</em>. It should be used for control of a process which must be completed, such as database updating or user identification.</p>
<dl>
<dt><strong><em>Toplevel</em></strong></dt>
<dd><p>Return control to the user interaction loop after applying the operation <em>recover</em> if it is present in the workspace.</p>
</dd>
<dt><strong><em>recover Msg</em></strong></dt>
<dd><p>The occurrence of any condition that forces a return to the interaction loop. The argument is the warning message which can be used to determine the cause of the jump.</p>
</dd>
<dt><strong><em>setinterrupts A</em></strong></dt>
<dd><p>Permit or prevent the interruption of computation. If <em>A</em> is <em>true</em>, interrupts are permitted; if it is <em>false</em>, interrupts are blocked. The default is to permit interrupts.</p>
</dd>
</dl>
<h2 id="fault-triggering">Fault Triggering</h2>
<p>Nial assumes that every computation that terminates results in an array value. However, there are many cases where a computation does not have a sensible answer. If division by zero occurs, for example, there is no suitable number to return. Nial uses special atomic arrays called <strong>faults</strong> to indicate such results. For division by zero it is <em>?div</em>.</p>
<p>Q'Nial has two ways of handling a fault:</p>
<ul>
<li><p>a trigger mechanism is executed that causes an interruption when a fault is created during execution of a defined operation, expression or transformer, or</p></li>
<li><p>the fault is treated as a normal atomic array.</p></li>
</ul>
<p>When Q'Nial is invoked, the fault triggering mecha nism is turned on by default. (This effect can be suppressed by using an option in the setup for each version). During execution, the state of the triggering mechanism can be turned on or off using the operation <em>settrigger</em>. The operation <em>quiet_fault</em>, defined in <em>defs.ndf</em>, can be used to create a fault without causing fault triggering. Fault triggering can be controlled using the following operations.</p>
<p><strong>Operation Action</strong></p>
<dl>
<dt><strong><em>settrigger A</em></strong></dt>
<dd><p>Permit or prevent the interruption of computation by the fault triggering mechanism. If <em>A</em> is <em>true</em>, a fault triggers an interrupt.</p>
</dd>
<dt><strong><em>quiet_fault A</em></strong></dt>
<dd><p>Return the result of <em>fault A</em> without causing fault triggering.</p>
</dd>
</dl>
<p>If fault triggering is set and a fault is generated during execution of a defined operation, execution is interrupted. On an interruption caused by a fault, a display mes sage appears giving the call stack of definitions currently executing and the line of text that caused the fault. For example, the definition:</p>
<pre><code>foo is op A B { A / B + 1 }</code></pre>
<p>followed by the evaluation of the expression</p>
<pre><code>foo 3 0</code></pre>
<p>results in the output:</p>
<pre><code>------------------------------------------------------------
Fault interruption loop: enter expressions or
type: \&lt;Return\&gt; to jump to top level
current call stack :
foo
?div triggered in : ... A / B
------------------------------------------------------------
&gt;&gt;&gt;</code></pre>
<p>where the string <em>?<strong>&gt;&gt;&gt;</strong>?</em> is a special prompt indicating that a fault has occurred and execution has been interrupted. The prompt permits you to query the value of variables in the expression and its surrounding computation or to view the operation that has triggered the fault. The above session might continue as:</p>
<pre><code>&gt;&gt;&gt; see ?foo
foo IS OPERATION A B {A / B + 1 }
&gt;&gt;&gt; A
3
&gt;&gt;&gt; B
0
&gt;&gt;&gt;</code></pre>
<p>A variable in a definition that called the current one can be referenced by preceding the variables name by the definition name and a colon, e.g.<em>G:X</em> denotes variable <em>X</em> in definition<em>G</em>. You can execute any expressions you want at the prompt. A useful thing to do is to <em>see</em> the definition that has interrupted. When you are ready to resume, reply to the prompt with a <em>Return</em> and control returns to the top level loop without an attempt to recover.</p>
<h2 id="workspace-management">Workspace Management</h2>
<p>To assist in the management of the workspace, Q'Nial has expressions and operations that are used in the following ways:</p>
<h2 id="saving-and-loading-the-workspace">Saving and Loading the Workspace</h2>
<p>Q'Nial includes mechanisms to save the contents of the current workspace in an external file and to load a previously saved workspace as the current one. During program development, workspaces can be used to avoid reloading a large definition file at the beginning of each session. Also, a workspace can encode an application that is shared with other users without providing the source to them.</p>
<p>The storage scheme used to store the workspace, designed to permit rapid saving and loading, is not portable between versions of Q'Nial on different systems or between revised versions on the same system. Hence, it is always wise to retain definition files in order to be able to reconstruct a workspace. A library program <em>wsdump.ndf</em> is available to convert the contents of a workspace into a definition file.</p>
<p>When a <em>save</em> or <em>load</em> is executed, the current computation is ended and the <em>Checkpoint</em> or <em>Latent</em> expression is done in the interaction loop environment. If a workspace being saved contains an expression named <em>Checkpoint</em>, the expression is executed following the saving of the workspace and prior to restarting the interaction loop. It can be used to restart a computational process after an intermediate dump of the workspace.</p>
<p>If a workspace being loaded contains an expression named <em>Latent</em>, the expression is executed following the load of the workspace and prior to restarting the interaction loop. <em>Latent</em> can be used to initiate a comput ational process or to set internal system variables prior to entering the interaction loop.</p>
<dl>
<dt><strong><em>save Wsname</em></strong></dt>
<dd><p>Save the current workspace under the name <em>Wsname</em> with extension <em>.nws</em>.</p>
</dd>
<dt><strong><em>load Wsname</em></strong></dt>
<dd><p>Load the workspace in the file named <em>Wsname</em> having exten sion <em>.nws</em>.</p>
</dd>
<dt><strong><em>Checkpoint</em></strong></dt>
<dd><p>User defined expression executed after a <em>save</em>.</p>
</dd>
<dt><strong><em>Latent</em></strong></dt>
<dd><p>User defined expression executed after a <em>load</em>.</p>
</dd>
</dl>
<p>With <em>load</em> or <em>save</em>, the extension <em>.nws</em> may be omitted in the filename. The filename can be specified as a phrase or a string. If the file naming convention on the host computer is sensitive to upper and lower case, care must be taken to spell the filename correctly.</p>
<h2 id="loading-a-definition-file">Loading a Definition File</h2>
<p>A definition file is a text file containing Q'Nial actions. It is viewed as a sequence of actions supplied to the system when the file is loaded. A definition file has the extension <em>.ndf</em> to distinguish it from other text files. The major purpose of definition files is to collect definitions of expressions, operations and transformers that form a module of code in an application. They may also provide a script of inputs for computations done without user interaction.</p>
<dl>
<dt><strong><em>loaddefs Fn Switch</em></strong></dt>
<dd><p>Read and execute the actions in definition file <em>Fn</em>. If <em>Switch</em> is <em>o</em> or is omitted, do not display the definitions; if <em>Switch</em> is <em>l</em>, display them.</p>
</dd>
<dt><strong><em>library Fn Switch</em></strong></dt>
<dd><p>Read and execute the actions in definition file <em>Fn</em> from directory <em>niallib</em>. If <em>Switch</em> is <em>o</em> or is omitted, do not display the definitions; if <em>Switch</em> is <em>l</em>, display them.</p>
</dd>
</dl>
<p>In <em>loaddefs, Fn</em> may be any path that leads to a file with a <em>.ndf</em> extension. The assumption is that the path starts from the current directory unless a complete path is given. In <em>library, Fn</em> can be any path that starts in the <em>niallib</em> directory. <em>Fn</em> can be specified as a phrase or a string. With <em>loaddefs</em> or <em>library</em>, the extension <em>.ndf</em> may be omitted in the filename.</p>
<p>The operation <em>library</em> uses the environment variable <em>nialroot</em> to find the directory that holds the subdirectory <em>niallib</em>and the other default libraries. The predefined variable <em>Libpath</em> can be set under program control to indicate other directories to be searched. The operation <em>library</em> is defined in the file <em>defs.ndf</em> and can be modified to provide an alternative library strategy.</p>
<h2 id="setting-workspace-switches">Setting Workspace Switches</h2>
<p>Q'Nial has a number of optional behaviours that depend on the value of internal switches. These are set by the mode setting operation <em>set</em>.</p>
<dl>
<dt><strong><em>set Switch</em></strong></dt>
<dd><p>Set an internal switch that controls how execution is displayed, controls tracing, or controls the output to log files. Return the previous setting. The settings are <em>sketch, diagram, decor, nodecor, trace, notrace, log</em>and<em>nolog</em>.</p>
</dd>
</dl>
<p>The switch setting can be specified as a phrase or a string in upper or lower case.</p>
<h2 id="workspace-status">Workspace Status</h2>
<p>The expression <em>Status</em> provides information about the workspace. Its results are explained as follows:</p>
<table style="width:135%;">
<colgroup>
<col width="29%" />
<col width="33%" />
<col width="72%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Position Value</th>
<th align="left">Value Given</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">number of free words</td>
<td align="left">amount of space available in workspace</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">largest free block size</td>
<td align="left">determines largest object that can be built</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">number of free blocks</td>
<td align="left">indicates the fragmentation of memory</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">workspace size</td>
<td align="left">gives the current size of the workspace</td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">size of internal stack</td>
<td align="left">used to hold intermediate values in evaluation</td>
</tr>
<tr class="even">
<td align="left">5</td>
<td align="left">size of phrase/fault table</td>
<td align="left">area used for hash table for phrases and faults</td>
</tr>
<tr class="odd">
<td align="left">6</td>
<td align="left">internal buffer size</td>
<td align="left">used for temporary space by many operations</td>
</tr>
</tbody>
</table>
<p>The last three items indicate the size of three internal areas that grow if required, but never shrink in size. After some large computations these components may be larger than needed. They are reset if the workspace saved and reloaded.</p>
<h2 id="symbol-table">Symbol Table</h2>
<p>Q'Nial maintains an internal <strong>symbol table</strong> holding the name and role of every object in the workspace. The following operations provide access to the symbol table information:</p>
<dl>
<dt><strong><em>symbols Sw</em></strong></dt>
<dd><p>If <em>Sw</em> is <em>o</em>, return a list of pairs of names and roles of all user-defined objects in the global environment. If<em>Sw</em> is <em>l</em>, also include the names and roles of predefined objects.</p>
</dd>
<dt><strong><em>erase A</em></strong></dt>
<dd><p>Erase the variable or definition specified by the phrase <em>A</em>.<br />
Leave the phrase <em>A</em> in the symbol table with its role unchanged but change its value to one of <em>?no_value, No_expr, no_op</em> or <em>NO_TR</em> depending on the role of <em>A</em>. This operation is used at top level to remove a user defined object from the current workspace. It permits the use of the identifier for a different purpose but not a differ ent role. It cannot be used to erase a name in a local scope.</p>
</dd>
<dt><strong><em>Vars</em></strong></dt>
<dd><p>The list of global variables in the workspace.</p>
</dd>
<dt><strong><em>Exprs</em></strong></dt>
<dd><p>The list of user-defined expressions in the workspace.</p>
</dd>
<dt><strong><em>Ops</em></strong></dt>
<dd><p>The list of user-defined operations in the workspace.</p>
</dd>
<dt><strong><em>Trs</em></strong></dt>
<dd><p>The list of user-defined transformers in the workspace.</p>
</dd>
</dl>
<p>The operation <em>symbols</em> returns a list of the items in the table. The operation <em>erase</em> removes the definition or variable from the workspace although the name remains in the symbol table with the same role. The expressions <em>Vars</em>, <em>Exprs</em>, <em>Ops</em> and <em>Trs</em> return the names of user-defined objects in each of these roles.</p>
<h2 id="logging-the-work-of-the-session">Logging the Work of the Session</h2>
<p>Q'Nial has a number of switches that can be set to permit logging the work of the session. The log file can also be renamed. The log file is opened and closed for each line that is written in order to ensure that it is retained if a session is terminated by an external process.</p>
<dl>
<dt><strong><em>set Logsw</em></strong></dt>
<dd><p>Set a switch that controls how logging is to be handled. Return the previous setting. The switch setting can be a phrase or a string in upper or lower case. The possible settings are <em>log, nolog</em> and <em>nolog</em>.</p>
</dd>
<dt><strong><em>setlogname Fn</em></strong></dt>
<dd><p>Set the name of the file used to log screen output to <em>Fn</em>, which can be a string or a phrase. The name is case sensitive if the host file system names are case sensitive.</p>
</dd>
</dl>
<p>The information displayed on the screen during a Q'Nial session is recorded in a log file if logging is activated by the <em>set &quot;log</em> action. The screen displays that occur during the host interface operations are not saved in the log file. The log file can be edited to make a working program from the series of trials made while working interactively. The default log file name is <em>auto.nlg</em>.</p>
<h2 id="time-related-expressions">Time Related Expressions</h2>
<p>Q'Nial provides two expressions which access the internal clock of the computer.</p>
<dl>
<dt><strong><em>Time</em></strong></dt>
<dd><p>System dependent timing information. On Unix, it is the processor time used for the user and system tasks for the process since the beginning of the session measured in seconds.</p>
</dd>
<dt><strong><em>Timestamp</em></strong></dt>
<dd><p>The current date and time in the form of a string.</p>
</dd>
</dl>
<h2 id="display-related-settings">Display Related Settings</h2>
<p>Q'Nial has a few settings that affect the way in which information is displayed on the screen.</p>
<dl>
<dt><strong><em>setprompt A</em></strong></dt>
<dd><p>Set the Q'Nial prompt to <em>A</em>, where <em>A</em> is a string or a phrase. The maxi mum length prompt is 40 characters.</p>
</dd>
<dt><strong><em>setwidth N</em></strong></dt>
<dd><p>Set the width of output displayed on the screen and sent to the log to <em>N</em> characters. The result is the previous screen width setting. Setting the output width to 0 allows the output to be of arbitrary length. Used by default in CGI-Nial.</p>
</dd>
<dt><strong><em>setformat Str</em></strong></dt>
<dd><p><em>Str</em> is a format specification for real numbers using the conventions for the <em>C</em> library routine <em>printf</em>. The result is the previous format setting.</p>
</dd>
<dt><strong><em>setscroll Mode</em></strong></dt>
<dd><p>Set the scroll setting for window mode to <em>Mode</em>. (Console versions only)</p>
</dd>
<dt><strong><em>Screensize</em></strong></dt>
<dd><p>Returns the height and width of the actual screen or window in use.</p>
</dd>
</dl>
<p>The default prompt displayed by Q'Nial in the interaction loop is a string of five blank characters. If a more visible prompt is preferred, <em>setprompt</em> can be used to change it.</p>
<p>Array pictures are written to the screen and to log files so that they fold as a unit; that is, if the array picture is too wide, all of its lines are displayed in the available space and then after a blank line the remain ing portion of the picture is displayed. The width of the display field defaults to the screen size but can be increased or decreased using <em>setwidth</em>.</p>
<h2 id="real-number-formatting">Real Number Formatting</h2>
<p>The three styles of real number formats that can be set using <em>setformat</em> are given below:</p>
<dl>
<dt><strong><em>'%f'</em></strong></dt>
<dd><p>displays a fixed number of places after the decimal point in a fixed size space with no scaling of the number,</p>
</dd>
<dt><strong><em>'%e'</em></strong></dt>
<dd><p>displays the number in scientific notation with an exponent scaling the number to have one digit before the decimal point, and</p>
</dd>
<dt><strong><em>'%g'</em></strong></dt>
<dd><p>displays the number in <em>f</em> format if possible but defaults to <em>e</em> format if the number is not within a suitable range.</p>
</dd>
</dl>
<p>Finer detail format specification is achieved by placing two numbers separated by a period between the '%' and the letter. For example '%15.5f ' uses a field of width 15 to display a number in <em>f</em> format with 5 decimal places. In general, the first digit refers to the width of the field. For <em>f</em> format the second digit gives the number of places after the decimal, while for <em>e</em> and <em>g</em> it indicates the number of significant digits to be displayed. Either digit can be left out</p>
<p>Because a real number display needs to be distinguishable from an integer, there are some cases where the field is one space wider than predicted by the format string in order to accommodate the decimal point added to the end. Also, if an <em>f</em> format is not wide enough for the number, it is widened so that the number is displayed.</p>
<p>The format string <em>'%.17g'</em> is used by the operation <em>display</em> in depicting real numbers. This format accurately reproduces the same number when executed on most platforms.</p>
<p>The default format is <em>'%g'</em>, which displays the number in a compact format displaying 5 significant digits. For numbers in the range 1e-5 &lt; x &lt; 1e6, it omits the exponent, for larger or smaller numbers the exponent is included. In both cases trailing zeros are removed.</p>
<h2 id="system-related-expressions">System Related Expressions</h2>
<p>There are four expressions which hold information about Q'Nial:</p>
<dl>
<dt><strong><em>Copyright</em></strong></dt>
<dd><p>The copyright message.</p>
</dd>
<dt><strong><em>Version</em></strong></dt>
<dd><p>The release and version of Q'Nial being used.</p>
</dd>
<dt><strong><em>System</em></strong></dt>
<dd><p>The operating system in use.</p>
</dd>
<dt><strong><em>Nialroot</em></strong></dt>
<dd><p>A string showing the path to the <em>nialroot</em> directory.</p>
</dd>
</dl>
<h2 id="host-interface-operations">Host Interface Operations</h2>
<p>Q'Nial provides access to the operating system and to an editor of choice.</p>
<dl>
<dt><strong><em>host Cmd</em></strong></dt>
<dd><p>Pass string or phrase <em>Cmd</em> to the host command processor for execution. The details of the use of <em>host</em> are specific to the operating system of the com puter being used. At the top level loop, an input line beginning with ! is treated as a host command. For most versions of Q?Nial, the host command causes Q'Nialto block until the command is completed.</p>
</dd>
<dt><strong><em>edit Filename</em></strong></dt>
<dd><p>Edit the text file named by the phrase or string <em>Filename</em> using the host default editor. Definition files can be prepared and modified from within Q'Nial so that sessions of Q'Nial are not interrupted to handle editing.</p>
</dd>
<dt><strong><em>defedit Def</em></strong></dt>
<dd><p>Place the definition named by phrase or string <em>Def</em> in a window in canonical form and invoke <em>editwindow</em> with the lines of the definition as strings in the window. After editing, execute the strings to load the definition. This is only available in the console versions of Q?Nial.</p>
</dd>
</dl>
<p>The operation <em>host</em> is platform dependent. Its argument is a command line that is executed by the command processor for the host system. If the command processor supports output redirection for the command in use then the results of host command can be sent to a file and obtained with <em>getfile</em>. An alternative is to use the pipe read mode of the operation <em>open</em> to have the lines of output of the result available using <em>readfile</em>. The library operation <em>newhost</em>implements a version of <em>host</em>that uses pipes.</p>
<p>The operation <em>edit</em> is used to access a standard text editor on the host system in console versions of Q'Nial. The editor to be used is determined by the environment variable <em>EDITOR</em> which the user can set in the operating system environment. If the variable is not set a default editor is chosen.</p>
<p><em>Defedit</em> is convenient for quick modification of an operation. Its definition is in file <em>defs.ndf</em>. It can be modified to suit individual tastes.</p>
<h2 id="session-and-workspace-variables">Session and Workspace Variables</h2>
<p>During execution of Q'Nial, a number of global variables within the interpreter determine how the environment behaves. These are classified as session or workspace variables depending on whether or not they are saved with the workspace and cause the environment to change when a workspace is loaded. The two tables below contain some internal variables that are only used with console versions.</p>
<table style="width:125%;">
<colgroup>
<col width="41%" />
<col width="30%" />
<col width="52%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Session Variable</th>
<th align="left">Default Setting</th>
<th align="left">Setting Operation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">log file setting</td>
<td align="left">nolog</td>
<td align="left">set ?log; set ?nolog</td>
</tr>
<tr class="even">
<td align="left">log file name</td>
<td align="left">auto.nlg</td>
<td align="left">setlogname Fnm</td>
</tr>
<tr class="odd">
<td align="left">screen display width</td>
<td align="left">80</td>
<td align="left">setwidth N</td>
</tr>
<tr class="even">
<td align="left">trace setting</td>
<td align="left">notrace</td>
<td align="left">set ?trace; set ?notrace</td>
</tr>
<tr class="odd">
<td align="left">interrupts enabled</td>
<td align="left">true</td>
<td align="left">setinterrupts M</td>
</tr>
<tr class="even">
<td align="left">fault triggering</td>
<td align="left">on</td>
<td align="left">settrigger M</td>
</tr>
<tr class="odd">
<td align="left">messages</td>
<td align="left">on</td>
<td align="left">setmessages M</td>
</tr>
<tr class="even">
<td align="left">prompt string</td>
<td align="left">5 blanks</td>
<td align="left">setprompt Str</td>
</tr>
<tr class="odd">
<td align="left">workspace size</td>
<td align="left">200,000 words</td>
<td align="left">command line option</td>
</tr>
<tr class="even">
<td align="left">stack size</td>
<td align="left">3,000</td>
<td align="left">N/A</td>
</tr>
<tr class="odd">
<td align="left">phrase/fault table size</td>
<td align="left">4,000</td>
<td align="left">N/A</td>
</tr>
<tr class="even">
<td align="left">Internal buffer</td>
<td align="left">1,000</td>
<td align="left">N/A</td>
</tr>
</tbody>
</table>
<p>The following table describes the workspace variables.</p>
<table>
<thead>
<tr class="header">
<th align="left">Workspace Variable</th>
<th align="left">Default Setting</th>
<th align="left">Setting Operation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">sketch/diagram switch</td>
<td align="left">sketch</td>
<td align="left">set ?sketch; set ?diagram</td>
</tr>
<tr class="even">
<td align="left">decor/nodecor switch</td>
<td align="left">nodecor</td>
<td align="left">set ?decor; set ?nodecor</td>
</tr>
<tr class="odd">
<td align="left">real format</td>
<td align="left">'%g'</td>
<td align="left">setformat Str</td>
</tr>
<tr class="even">
<td align="left">definition trace</td>
<td align="left"><em>o</em> for all definitions setdeftrace Defnm [M]</td>
</tr>
</tbody>
</table>
<p>The sizes of the workspace, the stack and the phrase and fault table are automatically increased as required during the session while space is available. Some of the session variables can be set using start up options that differ from version to version.</p>
<p>One approach to setting the programmable settings is to initialize them as desired in a <em>Latent</em> expression in a workspace that is loaded when a Q'Nial session is started. They session variables will then be set as Q'Nial is initialized or when the <em>Restart</em> expression is executed.</p>
<p>Workspace variables are internal settings that are preserved with the workspace. The above figure describes them. For example, if a workspace is saved with <em>diagram</em> and <em>nodecor</em> modes set, the reloaded workspace will retain those settings. However, if the <em>log</em> setting is in effect when the workspace is saved, nothing is recorded in the saved workspace to restore that setting on a reload of the workspace.</p>
<h1 id="chapter-9-debugging-and-profiling-nial-definitions">Chapter 9 Debugging and Profiling Nial Definitions</h1>
<h2 id="debugging-definitions">Debugging Definitions</h2>
<p>The Q'Nialsystem provides an optional debugging facility that aids interactive debugging. It is active by default, but can be turned off for running production applications. See the detailed documentation for the various versions on how to turn off debugging.</p>
<p>The debugging system is based on the idea of placing breaks in the code and stepping through the program code in a number of different ways. Due to constraints in the way Q'Nial is implemented, debugging is always done in the context of an expression sequence. A break point occurs either before the execution of the expression sequence in a definition, or at an explicit break expression within an expression sequence. There is also a watch mechanism that executes a defined action whenever the value of a variable changes, and an ability to monitor all uses of user defined objects and of the predefined operations.</p>
<h2 id="defining-a-break-point">Defining a Break Point</h2>
<p>There are two ways to cause a break in a Nial definition: by using the expression <em>Break</em>in an expression sequence, or by using the operation <em>breakin</em> to set a break on entry to an operation or expression.</p>
<dl>
<dt><strong><em>Break</em></strong></dt>
<dd><p>Suspend evaluation of the expression and pass control to an evaluation loop in the environment at the point of the Break. Variables accessible at that point can be displayed. This loop recognizes a number of commands described below.</p>
</dd>
<dt><strong><em>breakin Nm [M]</em></strong></dt>
<dd><p>Set or reset an internal break flag for the definiton of <em>Nm</em>. If the boolean value <em>M</em> is omitted, the flag is toggled. If set, a break occurs before the execution of the expression sequence of the definition. The Nm must be the name of a defined expression or a defined operation using the operation form style of operation expression.</p>
</dd>
<dt><strong><em>Breaklist</em></strong></dt>
<dd><p>Display the list of names of definitions with break flag set.</p>
</dd>
</dl>
<p>For console versions supporting the alphanumeric windows package, break mode can also be entered when Q'Nial is awaiting keyboard entry in window mode (except in <em>editwindow</em>) by typing &lt;Ctrl b&gt;. When normal operation is resumed, the previous screen is displayed and the input request is still pending.</p>
<p>When initially entering the &quot;debug mode&quot; because of a break caused by any of the above methods, a short banner is printed that indicates that the debug evaluation loop has been entered and it is followed by the expression to be executed and a prompt with a default debugging command.</p>
<pre><code>-------------------------------------------------------------
Break debug loop: enter debug commands, expressions or
type: resume to exit debug loop
&lt;Return&gt; executes the indicated debug command
current call stack :
foo
-------------------------------------------------------------

?.. C := A + ( + A + A )

--&gt;[stepv]</code></pre>
<p>Whenever you initially enter <em>debug mode</em>, the current callstack is printed to indicate where the break occurred. The debugging banner also reminds you that you can resume execution by typing resume and that hitting return will cause the debug action, indicated in square brackets at the prompt, to occur. The debugging action defaults to <em>stepv</em> but changes to the last debug command used if you execute another one.</p>
<p>At the debug prompt, the user can explore the values of variables by entering the variables name, can evaluate any Nial expression, say to display the definition with <em>see</em> or to get the <em>shape</em> of a variable, or can execute one of the debug commands described below that moves the computation forward.</p>
<p>A breakpoint set by the operation <em>breakin</em> sets an internal breakpoint flag. If the user reloads the definition (maybe as part of a <em>loaddefs</em>), then a breakpoint flag remains set if it was set. The breakpoint flag is also preserved if the workspace is saved and then subsequently loaded. Using <em>breakin</em> again or <em>erase</em> on the definition name clears the internal breakpoint flag. To clear all internal breakpoint flags execute</p>
<p><em>EACH breakin Breaklist</em></p>
<h2 id="access-to-intermediate-scopes">Access to Intermediate Scopes</h2>
<p>Nial has lexical scoping, that is a name is only directly visible in a definition if it is defined in the definition or in a surrounding one. For debugging, we often wish to look at the value of a variable in an operation that called the operation we are currently in. The scoped variable reference, one of the forms of a primary expression, is used to observe the value of local variables in named expressions that are blocks and in named operations that are operation forms. The use of a scoped variable reference produces the value of the variable for the most recent use of the definition in the call stack. The syntax is</p>
<p><em>funname:varname</em></p>
<p>This is general syntax that can be used under program control anywhere a variable reference is made, but can only be used to reference a variable, not to change it.</p>
<h2 id="debugging-commands">Debugging Commands</h2>
<p>The debugging commands permit resumption of execution in several forms, with or without the display of data computed during execution. The</p>
<dl>
<dt><strong><em>step(v) [N]</em></strong></dt>
<dd><p><em>step</em> executes the next executable expression (displayed after<em>?..</em>) in either the current definition or in a definition called within the current expression. It <em>steps into</em> definitions called within<br />
 an expression. If <em>stepv</em> is used, the value of the executed expression is displayed. If N is provided (N&gt;=1) then the command is executed N<br />
 times before the user is prompted again.</p>
</dd>
<dt><strong><em>next(v) [N]</em></strong></dt>
<dd><p><em>next</em> is similar to <em>step</em> except that it does not go into definition calls, but rather, executes a definition within a the current expression quietly. It is used to trace the statements within one definition, without showing the detailed execution of definitions that are called by the current expression. If <em>nextv</em> is used, the value of the executed expression is displayed. If N is provided then the command is executed N times before the user is prompted again.</p>
</dd>
<dt><strong><em>stepin [N]</em></strong></dt>
<dd><p><em>stepin</em> is the same as <em>step</em> except that it traces the evaluation of the next expression to be executed. It is useful for seeing the details of how an expression is computing its value.</p>
</dd>
<dt><strong><em>toend(v)</em></strong></dt>
<dd><p><em>toend</em> executes to the end of a loop or of a definition. It is useful if you want to skip all of the remaining expressions within a loop or an expression sequence in a definition and stop on the first expression after the loop or definition call.</p>
</dd>
<dt><strong><em>resume</em></strong></dt>
<dd><p><em>resume</em> continues program execution until either another <em>break</em> or <em>fault</em> is encountered, or until the expression being executed completes.</p>
</dd>
</dl>
<p>The debugging facilities can be used in a number of different ways. For example, you can step forward from a breakpoint using <em>nextv</em>, <em>stepv</em>, or <em>stepin</em>, depending on the details you wish to observe. If a <em>breakin</em> is used to break in a definition then you may want to use next to move quickly to the area where the problem is. Alternatively, you can edit the definition and insert a <em>Break</em> expression at the point of concern and reload the definition. Then execution will be interrupted at that point and you can enter variable references to observe the value of variables that affect the computation, or try out parts of the next expression to be executed to see why it is not working as expected.</p>
<p>Another way to get debugging started at a convenient place is to place a watch on a variable with its corresponding action being a break. See the section below on the Watch Mechanism.</p>
<p>The debugging commands <em>step</em> and <em>next</em> have special behaviour for the control structure expressions such as if-then-else and while-do expressions. When the next expression is a control structure expression only two lines of it are displayed. If <em>next</em> or <em>step</em> are given as the command, then the next expression becomes one of the components in the control structure expression. For example, in an if-expression, the next expression becomes the boolean expression following <em>IF</em>. Nothing is executed, just the focus of debugging has moved into the control construct. If the value versions of the command are used, then on the execution of the last expression in the control construct, both the value for the last expression and the value for the entire control construct are displayed.</p>
<p>The <em>toend</em> command serves a dual purpose: it is used to terminate a loop, or to terminate a definition. If execution is in a loop and <em>toend</em> is given as the command, then all the remaining iterations of the loop are executed and execution stops after completion of the loop. If the current loop is nested within another, only the inner loop is executed to completion.</p>
<p>If the <em>toend</em> command is given at the debug prompt and the current expression is not within a loop, then the execution continues to the end of the definition. If the definition had been called during the execution of an expression by using <em>step</em> or <em>stepv</em> then the execution will stop on the expression following the definition. If the break that started debug mode was in the definition, then <em>toend</em> behaves like <em>resume</em>.</p>
<p>In the rare case where there is a conflict between a variable name and a debugging command you can precede an expression given in the debugging loop with a backslash (\) to indicate that it is an expression to be evaluated.</p>
<h2 id="repeating-debug-commands">Repeating Debug Commands</h2>
<p>All versions of the debug commands also allow the addition of an integer argument. This argument is interpreted as the number of times to execute the given debug command, before returning to the debug prompt. For example, using the debug command <em>nextv 10</em> will show all the results of <em>nextv</em> as if the command was issued ten times. After ten executions, the debug prompt is printed</p>
<h2 id="monitoring-execution-flow">Monitoring Execution Flow</h2>
<p>In trying to understand the behaviour of a program it is sometimes necessary to trace the flow of execution to see how the flow has gone. The operations described in the next table assist in this endeavour.</p>
<p>Debugging is an art. There is no best way to use the debugging facilities to solve a problem. For complex situations where the problem involves deeply nested definition calls, it may be convenient to issue <em>Callstack</em> to find out what definition is executing, and at what level of nesting it is at. Also using <em>see</em> on the current definition helps to see the context in which the debugging is occurring.</p>
<dl>
<dt><strong><em>Callstack</em></strong></dt>
<dd><p>Display the sequence of active definitions at the point of the break.</p>
</dd>
<dt><strong><em>seeusercalls M</em></strong></dt>
<dd><p>Set the flag that controls display of entry to and exit from user definitions to boolean value M. If M is True then display the call information.</p>
</dd>
<dt><strong><em>seeprimcalls M</em></strong></dt>
<dd><p>Set the flag that controls display of the execution of primitive functions to boolean value M. If M is True then display the call information.</p>
</dd>
</dl>
<h2 id="watch-mechanism">Watch Mechanism</h2>
<p>The debugging system also includes an ability to place a <em>watch</em> on a global or local variable. The capabilities are:</p>
<dl>
<dt><strong><em>watch Var Expr</em></strong></dt>
<dd><p>Set a watch on the variable given by cast <em>Var</em> if <em>Expr</em> is a non-empty string. If <em>Expr</em> is empty, remove the watch from the variable.</p>
</dd>
<dt><strong><em>Watchlist</em></strong></dt>
<dd><p>Return the list of watch variables and expressions that are currently set.</p>
</dd>
</dl>
<p>The approach is to associate an expression to be executed when the value of the variable changes. The expression can display the value that has been assigned, or execute a <em>Break</em> expression to interrupt the computation. The variable is referenced by a <em>cast</em>, for a global variable <em>X</em>, the cast is<em>!X</em>, for a local variable <em>Y</em> in definition <em>G</em>, the cast is <em>!G:Y</em>. The action to be performed is given as a string of program text that denotes an expression.</p>
<h2 id="trace-mechanism">Trace Mechanism</h2>
<p>The trace facility has two capabilities: to trace the execution of expressions at the top level and to trace the evaluation of the application of a defined opera tion.</p>
<dl>
<dt><strong><em>set Tracemode</em></strong></dt>
<dd><p>The action <em>set &quot;trace</em> causes the execution of expressions at the top level to be traced. It presents the result of the application of a defined operation but does not trace the evaluation of the defined operation. Trace mode is turned off by the action <em>set &quot;notrace</em>.</p>
</dd>
<dt><strong><em>setdeftrace Def [Sw]</em></strong></dt>
<dd><p>Change the trace mode setting for definition <em>Def</em>. If <em>Sw</em> is <em>true</em>, turn on tracing; if it is <em>false</em>, turn it off. If <em>Sw</em> is omitted, reverse the setting.</p>
</dd>
</dl>
<p>The trace mechanism provides a lot of output for the evaluation of an expression. The intermediate expressions within the expression being traced are displayed and their values printed. This is appropriate for small values, but becomes unwieldy for large data objects. Thus, debugging with tracing is best done with small arrays. The output produced by tracing is captured by the log facility and hence it possible to study the details of the execution <em>after the fact</em>.</p>
<h2 id="profiling-capability">Profiling Capability</h2>
<p>Q'Nial has a profiling capability that can be used to gather relative execution times for defined operations, transformers and expressions. The data on execution times is collected relative to the tree of function calls, so that both the total time a routine is used and the time it is used from a specific other routine can be computed. The profiling capability makes it easier to find inefficiencies in Nial programs. The following summarizes the capabilities.</p>
<dl>
<dt><strong><em>setprofile M</em></strong></dt>
<dd><p>sets the internal flag that turns on or off the collection of data on execution time to <em>M</em>. If <em>M</em> is True the data is gathered.</p>
</dd>
<dt><strong><em>profile Fnm</em></strong></dt>
<dd><p>displays the profile data to the screen if <em>Fnm</em> is the empty string or writes it to the file named by <em>Fnm</em>.</p>
</dd>
<dt><strong><em>Clearprofile</em></strong></dt>
<dd><p>clears the current profile information and reinitializes the profiling system.</p>
</dd>
<dt><strong><em>profiletable</em></strong></dt>
<dd><p>provides the profile information as a table</p>
</dd>
<dt><strong><em>profiletree</em></strong></dt>
<dd><p>provides detailed profile information in terms of the tree of calls.</p>
</dd>
</dl>
<p>The profiling capabilities are described in more detail in the <em>Nial Dictionary</em>.</p>
</body>
</html>
